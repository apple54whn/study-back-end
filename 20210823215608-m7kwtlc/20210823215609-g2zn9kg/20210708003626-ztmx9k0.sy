{
	"ID": "20210708003626-ztmx9k0",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20210708003626-ztmx9k0",
		"title": "301.高级",
		"type": "doc",
		"updated": "20210708003626"
	},
	"Children": [
		{
			"ID": "20210708003626-ku7kcaf",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210708003626-ku7kcaf"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "系统是如何与 MySQL 打交道？"
				}
			]
		},
		{
			"ID": "20210708003626-tbnqlas",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-tbnqlas"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "驱动的引入—建立连接"
				}
			]
		},
		{
			"ID": "20210708003626-k5oimyx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-k5oimyx"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "都知道，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "访问数据库必须得跟数据库建立网络连接"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。回忆 IDEA 中的数据库工具建立连接时是不是需要下载 driver，这个就是 "
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "MySQL 的驱动，它会在底层跟数据库建立网络连接"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210708003626-mug7ygf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-mug7ygf"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当然 Java 代码如何使用该驱动呢？看如下 maven 依赖："
				}
			]
		},
		{
			"ID": "20210708003626-la1zhih",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "eG1s",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210708003626-la1zhih"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "eG1s"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "\u003cdependency\u003e\n    \u003cgroupId\u003emysql\u003c/groupId\u003e\n    \u003cartifactId\u003emysql-connector-java\u003c/artifactId\u003e\n    \u003cscope\u003eruntime\u003c/scope\u003e\n\u003c/dependency\u003e\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210708003626-julr0dv",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-julr0dv"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这就是 mysql 适配的 java 版本的连接驱动，当然还会有 Go、Python、JS 等版本"
				}
			]
		},
		{
			"ID": "20210708003626-am8xeg4",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-am8xeg4"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "连接池（应用）—连接数量、复用"
				}
			]
		},
		{
			"ID": "20210708003626-d5sdo9q",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-d5sdo9q"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "一个 Java 系统难道只会跟数据库建立一个连接吗？不可能，例如一个部署在 Tomcat 中的 Web 应用，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "Tomcat 本身肯定是由多个线程来并发的处理同时接收到的多个请求"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的。"
				}
			]
		},
		{
			"ID": "20210708003626-gqh3ws6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-gqh3ws6"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个时候，如果 Tomcat 中的多个线程并发处理多个请求的时候，都要去抢夺一个连接去访问数据库的话，那效率肯定是很低下的"
				}
			]
		},
		{
			"ID": "20210708003626-ecgsc6l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-ecgsc6l"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "若 Tomcat 中的每个线程在每次访问数据库的时候，都基于 MySQL 驱动去创建一个数据库连接，然后执行 SQL 语句，然后执行完之后再销毁这个数据库连接。导致可能 Tomcat 中上百个线程会并发的频繁创建数据库连接，执行 SQL 语句，然后频繁的销毁数据库连接。这也是非常不好的，因为"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "每次建立一个数据库连接都很耗时"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-ggwx9qh",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-ggwx9qh"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以一般我们必须要使用一个数据库连接池，也就是说在一个池子里维持多个数据库连接，让多个线程使用里面的不同的数据库连接去执行 SQL 语句，然后执行完 SQL 语句之后，不要销毁这个数据库连接，而是把连接放回池子里，后续还可以继续使用。"
				}
			]
		},
		{
			"ID": "20210708003626-fj35sl2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-fj35sl2"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "基于这样的一个数据库连接池的机制，就可以解决多个线程并发的使用多个数据库连接去执行 SQL 语句的问题，而且还避免了数据库连接使用完之后就销毁的问题，我们看下图的说明。"
				}
			]
		},
		{
			"ID": "20210708003626-ji9rr5y",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-ji9rr5y"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "连接池（MySQL）"
				}
			]
		},
		{
			"ID": "20210708003626-8a9i4os",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-8a9i4os"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "任何一个系统都会有一个数据库连接池去访问数据库，也就是说这个系统会有多个数据库连接，供多线程并发的使用。同时我们可能会有"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "多个系统同时去访问一个数据库"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，这都是有可能的。那就是会有很多系统要与 MySQL 数据库建立很多个连接，那么 MySQL 也必然要"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "维护 MySQL 与系统之间的多个连接"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，所以"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "MySQL 架构体系中的第一个环节，就是连接池"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210708003626-tylzhl7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-tylzhl7"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "实际上"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "MySQL 中的连接池就是维护了与系统之间的多个数据库连接"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。除此之外，你的系统每次跟 MySQL 建立连接的时候，还会根据你传递过来的账号和密码，进行"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "账号密码的验证，库表权限的验证"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210708003626-b9tnvhw",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-b9tnvhw"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "MySQL 架构 \u0026 执行流程"
				}
			]
		},
		{
			"ID": "20210708003626-73mxe6i",
			"Type": "NodeIFrame",
			"Data": "\u003ciframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display: block; width: 1000px; height: 846px;\" src=\"https://www.processon.com/embed/6011900ce401fd6d26c261d6\" data-src=\"https://www.processon.com/embed/6011900ce401fd6d26c261d6\"\u003e\u003c/iframe\u003e",
			"Properties": {
				"id": "20210708003626-73mxe6i",
				"updated": "20210708003626"
			}
		},
		{
			"ID": "20210708003626-cduxav9",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210708003626-cduxav9"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "一条更新语句在 InnoDB 中的执行流程"
				}
			]
		},
		{
			"ID": "20210708003626-ed7c74b",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-ed7c74b"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "图示"
				}
			]
		},
		{
			"ID": "20210708003626-nwbjkdp",
			"Type": "NodeIFrame",
			"Data": "\u003ciframe id=\"embed_dom\" name=\"embed_dom\" frameborder=\"0\" style=\"display: block; width: 1054px; height: 849px;\" src=\"https://www.processon.com/embed/6012cd61e401fd6d26c6594e\" data-src=\"https://www.processon.com/embed/6012cd61e401fd6d26c6594e\"\u003e\u003c/iframe\u003e",
			"Properties": {
				"id": "20210708003626-nwbjkdp",
				"updated": "20210708003626"
			}
		},
		{
			"ID": "20210708003626-mdud1bb",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-mdud1bb"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "更新语句在 MySQL 中是如何执行的？"
				}
			]
		},
		{
			"ID": "20210708003626-rjp00zz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-rjp00zz"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先假设我们有一条 SQL 语句是这样的："
				}
			]
		},
		{
			"ID": "20210708003626-az1hwsq",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "c3Fs",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210708003626-az1hwsq"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "c3Fs"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "update users set name='xxx' where id=10\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210708003626-52o3kx4",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-52o3kx4"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "Buffer Pool—缓冲池"
				}
			]
		},
		{
			"ID": "20210708003626-q7323gu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-q7323gu"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "InnoDB 存储引擎中有一个非常重要的放在"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "内存里的组件"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，就是缓冲池（Buffer Pool），这里面会缓存很多的数据，以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了"
				}
			]
		},
		{
			"ID": "20210708003626-lbx3ot4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-lbx3ot4"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "要执行更新语句的时候 ，比如对“id=10”这一行数据，他其实会先将“id=10”这一行数据"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "看看是否在缓冲池里"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，如果不在的话，那么会直接"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "从磁盘里加载到缓冲池里"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "来，而且接着还会"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "对这行记录加独占锁（不允许别人同时更新）"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-viqf2wr",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-viqf2wr"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "undo 日志文件"
				}
			]
		},
		{
			"ID": "20210708003626-xr4urfc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-xr4urfc"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接着下一步，假设“id=10”这行数据的 name 原来是“zhangsan”，现在我们要更新为“xxx”，那么此时我们得先把要更新的"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "原来的值"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "“zhangsan”和“id=10”这些信息，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "写入到 undo 日志文件"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "中去。"
				}
			]
		},
		{
			"ID": "20210708003626-fo1aeuy",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-fo1aeuy"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "更新 buffer pool 中的缓存数据"
				}
			]
		},
		{
			"ID": "20210708003626-wbizww0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-wbizww0"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当我们把要更新的那行记录从磁盘文件加载到缓冲池，同时对他加锁之后，而且还把更新前的旧值写入 undo 日志文件之后，我们就可以正式开始更新这行记录了，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "更新的时候"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "先是会更新缓冲池中的记录"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，此时这个数据就是"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "脏数据"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "了。"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "磁盘和内存值不同"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210708003626-2tqevq0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-2tqevq0"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里所谓的更新内存缓冲池里的数据，意思就是把内存里的“id=10”这行数据的 name 字段修改为“xxx”。那么为什么说此时这行数据就是脏数据了呢？因为这个时候磁盘上“id=10”这行数据的 name 字段还是“zhangsan”，但是内存里这行数据已经被修改了，所以就会叫他是脏数据。"
				}
			]
		},
		{
			"ID": "20210708003626-hm0lkal",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-hm0lkal"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "Redo Log Buffer—万一系统宕机，如何避免数据丢失？"
				}
			]
		},
		{
			"ID": "20210708003626-vr3c49l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-vr3c49l"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接着我们来思考一个问题，按照上图的说明，现在已经把内存里的数据进行了修改，但是磁盘上的数据还没修改。那么此时万一 MySQL 所在的机器宕机了，必然会导致内存里修改过的数据丢失，这可怎么办呢？"
				}
			]
		},
		{
			"ID": "20210708003626-2rmm9ga",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-2rmm9ga"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个时候，就必须要把对内存所做的修改写入到一个"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "Redo Log Buffer"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "里去，这也是内存里的一个缓冲区，是用来存放 redo 日志的，记录下来你对数据做了什么修改，比如对“id=10 这行记录修改了 name 字段的值为 xxx”，这就是一个日志。"
				}
			]
		},
		{
			"ID": "20210708003626-vzwicxw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-vzwicxw"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个 redo 日志其实是用来在 MySQL 突然"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "宕机"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的时候，用来"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "恢复你更新过的数据"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的。但此时 redo 日志还仅仅停留在内存缓冲区里"
				}
			]
		},
		{
			"ID": "20210708003626-k6bx1ri",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-k6bx1ri"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "如果还没提交事务，MySQL 宕机了怎么办？"
				}
			]
		},
		{
			"ID": "20210708003626-94fsqbs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-94fsqbs"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "到目前为止，其实还没有提交事务，那么此时如果 MySQL 崩溃，必然导致内存里 Buffer Pool 中的修改过的数据都丢失，同时你写入 Redo Log Buffer 中的 redo 日志也会丢失。那么此时数据丢失要紧吗？"
				}
			]
		},
		{
			"ID": "20210708003626-4y5wvnf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-4y5wvnf"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其实是不要紧的，因为你一条更新语句，没提交事务，就代表他没执行成功，此时 MySQL 宕机虽然导致内存里的数据都丢失了，但是你会发现，磁盘上的数据依然还停留在原样子。也就是说，“id=1”的那行数据的 name 字段的值还是老的值，“zhangsan”，所以此时你的这个事务就是执行失败了，没能成功完成更新，你会收到一个数据库的异常。然后当 mysql 重启之后，你会发现你的数据并没有任何变化。所以此时如果 mysql 宕机，不会有任何的问题。"
				}
			]
		},
		{
			"ID": "20210708003626-h291rdf",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-h291rdf"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "提交事务的时候将 redo 日志写入磁盘中"
				}
			]
		},
		{
			"ID": "20210708003626-e0b8axf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-e0b8axf"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "接着我们想要提交一个事务了，此时就会根据一定的策略（这个策略是通过"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "innodb_flush_log_at_trx_commit"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "来配置）把 redo 日志从 redo log buffer 里刷入到磁盘文件里去。此时可能处于的一个状态："
				}
			]
		},
		{
			"ID": "20210708003626-e0y6t8a",
			"Type": "NodeList",
			"ListData": {
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210708003626-e0y6t8a"
			},
			"Children": [
				{
					"ID": "20210708003626-fza18b0",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210708003626-fza18b0"
					},
					"Children": [
						{
							"ID": "20210708003626-r6ezk8e",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-r6ezk8e"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当这个参数的值为 0 的时候，那么你"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "提交事务"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "的时候，"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "不会把 redo log buffer 里的数据刷入磁盘文件"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "的，此时可能你都提交事务了，结果 mysql 宕机了，然后此时内存里的数据全部丢失。相当于你"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "提交事务成功"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "了，但是由于 MySQL 突然宕机，导致"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "内存中的数据和 redo log buffer 都丢失"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "了。"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "丢数据！"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20210708003626-rr7qpo0",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210708003626-rr7qpo0"
					},
					"Children": [
						{
							"ID": "20210708003626-ei3xexu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-ei3xexu"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当这个参数的值为 1 的时候，你"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "提交事务的时候，就必须把 redo log 从内存刷入到磁盘文件"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "里去，"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "只要事务提交成功"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "那么 redo log 就必然在磁盘里"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "了。此时你肯定会有一条 redo 日志说了，“我此时对哪个数据做了一个什么修改，比如 name 字段修改为 xxx 了”。"
								}
							]
						},
						{
							"ID": "20210708003626-8ejcru2",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-8ejcru2"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "然后哪怕此时 buffer pool 中更新过的数据还没刷新到磁盘里去，此时内存里的数据是已经更新过的“name=xxx”，然后磁盘上的数据还是没更新过的“name=zhangsan”。"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "有 redo log 保障最终一致！"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "mysql 重启之后，他可以根据 redo 日志去恢复之前做过的修改"
								}
							]
						}
					]
				},
				{
					"ID": "20210708003626-e17io76",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210708003626-e17io76"
					},
					"Children": [
						{
							"ID": "20210708003626-m3x9t1s",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-m3x9t1s"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "当这个参数的值为 2 的时候，意思就是，提交事务的时候，把 redo 日志"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "写入磁盘文件对应的 os cache 缓存"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "里去，而不是直接进入磁盘文件，"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "可能 1 秒后才会把 os cache 里的数据写入到磁盘文件"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "里去"
								}
							]
						},
						{
							"ID": "20210708003626-u3s1fd8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-u3s1fd8"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "这种模式下，你提交事务之后，"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "redo log 可能仅仅停留在 os cache 内存缓存"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "里，没实际进入磁盘文件，万一此时你要是机器宕机了，那么"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "os cache 里的 redo log 就会丢失"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，同样会让你感觉提交事务了，结果数据丢了"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-cqehl8n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-cqehl8n"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对于关系数据库这样严格的系统而言，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "一般建议 redo 日志刷盘策略设置为 1"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，保证事务提交之后，数据绝对不能丢失"
				}
			]
		},
		{
			"ID": "20210708003626-3lo1jqw",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-3lo1jqw"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "bin log 日志文件"
				}
			]
		},
		{
			"ID": "20210708003626-g35cvu6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-g35cvu6"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "不同之处"
				}
			]
		},
		{
			"ID": "20210708003626-8gmddxh",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210708003626-8gmddxh"
			},
			"Children": [
				{
					"ID": "20210708003626-o2pv24a",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210708003626-o2pv24a"
					},
					"Children": [
						{
							"ID": "20210708003626-6fy7ivi",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-6fy7ivi"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "之前说的 redo log，他是一种"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "偏向物理性质的重做日志"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，因为他里面记录的是类似这样的东西，“对哪个"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "数据页"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "中的什么记录，做了个什么修改”。而且 redo log 本身是"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "属于 InnoDB 存储引擎特有"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "的一个东西。"
								}
							]
						}
					]
				},
				{
					"ID": "20210708003626-fh9h2ks",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210708003626-fh9h2ks"
					},
					"Children": [
						{
							"ID": "20210708003626-ikiaj85",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-ikiaj85"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "而 binlog 叫做归档日志，他里面记录的是偏向于"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "逻辑性的日志"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，类似于“对"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "users 表中的 id=10 的一行数据做了更新操作，更新以后的值是什么"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "”。"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "属于 mysql server 自己的日志文件"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-qemltwt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-qemltwt"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在我们提交事务的时候，会把 redo log 日志写入磁盘文件中去。然后其实在提交事务的时候，我们"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "同时还会把这次更新对应的 binlog 日志写入到磁盘文件中去"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-9f938e6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-9f938e6"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对于 binlog 日志，其实也有不同的刷盘策略，有一个"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "sync_binlog"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "参数可以控制 binlog 的刷盘策略，他的默认值是 0，"
				}
			]
		},
		{
			"ID": "20210708003626-fqg8ebs",
			"Type": "NodeList",
			"ListData": {
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210708003626-fqg8ebs"
			},
			"Children": [
				{
					"ID": "20210708003626-c6qxy8g",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210708003626-c6qxy8g"
					},
					"Children": [
						{
							"ID": "20210708003626-7o9bnr5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-7o9bnr5"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "值为 0 时，此时你把 binlog 写入磁盘的时候，其实不是直接进入磁盘文件，而是进入 os cache 内存缓存。"
								}
							]
						},
						{
							"ID": "20210708003626-691mp8a",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-691mp8a"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "跟之前分析的一样，如果此时机器宕机，那么你在 os cache 里的"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "binlog 日志是会丢失"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "的"
								}
							]
						}
					]
				},
				{
					"ID": "20210708003626-x6u43i2",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210708003626-x6u43i2"
					},
					"Children": [
						{
							"ID": "20210708003626-85bvprt",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-85bvprt"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "值为 1 时，此时会强制在准备提交事务的时候，把 binlog 直接写入到磁盘文件里去，那么这样提交事务之后，哪怕机器宕机，磁盘上的 binlog 是不会丢失的"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-5cbir60",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-5cbir60"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "基于 binlog 和 redo log 完成事务的提交"
				}
			]
		},
		{
			"ID": "20210708003626-r3ha6k6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-r3ha6k6"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当我们"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "把 binlog 写入磁盘文件"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "之后，接着就会完成"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "最终的事务提交"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，此时会"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "把本次更新对应的 binlog 文件名称"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "和"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "这次更新的 binlog 日志在文件里的位置"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，都"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "写入到 redo log 日志文件里"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "去，同时在 redo log 日志文件里"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "写入一个 commit 标记"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。在完成这个事情之后，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "才算最终完成了事务的提交"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-zm3hpam",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-zm3hpam"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "redo 日志中写入 commit 标记的意义是什么？"
				}
			]
		},
		{
			"ID": "20210708003626-w5s2f3d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-w5s2f3d"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "用来"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "保持 redo log 日志与 binlog 日志一致"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的。"
				}
			]
		},
		{
			"ID": "20210708003626-8y04pvy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-8y04pvy"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "举个例子，假设我们在提交事务的时候，一共有上图中的 5、6、7 三个步骤，必须是三个步骤都执行完毕，才算是提交了事务。那么在我们刚完成步骤 5 的时候，也就是 redo log 刚刷入磁盘文件的时候，mysql 宕机了，此时怎么办？"
				}
			]
		},
		{
			"ID": "20210708003626-o4bkkyz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-o4bkkyz"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个时候因为没有最终的事务 commit 标记在 redo 日志里，所以此次事务可以判定为不成功。不会说 redo 日志文件里有这次更新的日志，但是 binlog 日志文件里没有这次更新的日志，不会出现数据不一致的问题。"
				}
			]
		},
		{
			"ID": "20210708003626-tkopad5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-tkopad5"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果要是完成步骤 6 的时候，也就是 binlog 写入磁盘了，此时 mysql 宕机了，怎么办？"
				}
			]
		},
		{
			"ID": "20210708003626-bd4wemo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-bd4wemo"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "同理，因为没有 redo log 中的最终 commit 标记，因此此时事务提交也是失败的。"
				}
			]
		},
		{
			"ID": "20210708003626-8adfmk1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-8adfmk1"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "必须是在 redo log 中写入最终的事务 commit 标记了，然后此时事务提交成功"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，而且 redo log 里有本次更新对应的日志，binlog 里也有本次更新对应的日志 ，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "redo log 和 binlog 完全是一致的"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210708003626-vwfrkcw",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-vwfrkcw"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "后台 IO 线程随机将内存更新后的脏数据刷回磁盘"
				}
			]
		},
		{
			"ID": "20210708003626-t8dd308",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-t8dd308"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "现在我们假设已经提交事务了，此时一次更新“update users set name='xxx' where id=10”，他已经把内存里的 buffer pool 中的缓存数据更新了，同时磁盘里有 redo 日志和 binlog 日志，都记录了把我们指定的“id=10”这行数据修改了“name='xxx'”。"
				}
			]
		},
		{
			"ID": "20210708003626-zi5s8ls",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-zi5s8ls"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "此时我们会思考一个问题了，但是这个时候磁盘上的数据文件里的“id=10”这行数据的 name 字段还是等于 zhangsan 这个旧的值啊！"
				}
			]
		},
		{
			"ID": "20210708003626-dotv0ft",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-dotv0ft"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以 MySQL 有一个后台的 IO 线程，会在之后某个时间里，随机的把内存 buffer pool 中的修改后的脏数据给刷回到磁盘上的数据文件里去。当 IO 线程把 buffer pool 里的修改后的脏数据刷回磁盘的之后，磁盘上的数据才会跟内存里一样，都是 name=xxx 这个修改以后的值了！"
				}
			]
		},
		{
			"ID": "20210708003626-vecn2bx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-vecn2bx"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在你 IO 线程把脏数据刷回磁盘之前，哪怕 mysql 宕机崩溃也没关系，因为重启之后，会根据 redo 日志恢复之前提交事务做过的修改到内存里去，就是 id=10 的数据的 name 修改为了 xxx，然后等适当时机，IO 线程自然还是会把这个修改后的数据刷到磁盘上的数据文件里去的"
				}
			]
		},
		{
			"ID": "20210708003626-iea1v3n",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-iea1v3n"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "思考题：执行更新操作的时候，为什么不能执行修改磁盘上的数据？"
				}
			]
		},
		{
			"ID": "20210708003626-ga5qk9a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-ga5qk9a"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "为什么 MySQL 在更新数据的时候，要大费周章的搞这么多事情，包括 buffer pool、redo log、undo log、binlog、事务提交、脏数据。引入了一大堆的概念，有复杂的流程和步骤。"
				}
			]
		},
		{
			"ID": "20210708003626-sa6zf23",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-sa6zf23"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为来一个请求就直接对磁盘文件进行"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "随机读写（重点）"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，然后更新磁盘文件里的数据，虽然技术上是可以做到的，但是那必然导致执行请求的性能极差。因为"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "磁盘随机读写的性能是最差"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的，所以直接更新磁盘文件，必然导致我们的数据库完全无法抗下任何一点点稍微高并发一点的场景。所以 MySQL 才设计了如此复杂的一套机制，通过内存里更新数据，然后写 redo log 以及事务提交，后台线程不定时刷新内存里的数据到磁盘文件里。通过这种方式保证，你每个更新请求，尽量就是"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "更新内存"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，然后"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "顺序写日志文件"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "更新内存的性能是极高"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的，然后"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "顺序写磁盘上的日志文件的性能也是比较高"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的，因为顺序写磁盘文件，他的性能要远高于随机读写磁盘文件。也正是通过这套机制，才能让我们的 MySQL 数据库在较高配置的机器上，每秒可以抗下几千的读写请求。"
				}
			]
		},
		{
			"ID": "20210708003626-63y049d",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210708003626-63y049d"
			},
			"Children": [
				{
					"ID": "20210708003626-6n1e5wn",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210708003626-6n1e5wn"
					},
					"Children": [
						{
							"ID": "20210708003626-11dysok",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-11dysok"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "为什么他反而最关键的修改磁盘里的数据，要通过 IO 线程不定时的去执行？"
								}
							]
						}
					]
				},
				{
					"ID": "20210708003626-luq8s2o",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210708003626-luq8s2o"
					},
					"Children": [
						{
							"ID": "20210708003626-xclsijf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-xclsijf"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "为什么他不干脆直接就每次执行 SQL 语句，直接就更新磁盘里的数据得了？"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-7nbz1co",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-7nbz1co"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "edo(物理日志)记录的是哪一页哪个位置做了什么变动，顺序写，不用去用 SQL 找相应位置. binlog 记录完整的 SQL, 可以依靠这个恢复某一个时刻的。 如果当确定 redo 日志和 binlog 日志都已经提交后,还要再次修改磁盘数据,首先性能会减慢，因为要确保更新成功,其次，如果修改磁盘数据时，宕机了,redo 日志和 Binlog 保存的日志就没有作用。 如果每次执行 SQL 语句，直接更新磁盘数据, 频繁 IO 读写，性能很慢"
				}
			]
		},
		{
			"ID": "20210708003626-d3ltykq",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-d3ltykq"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "思考题：IO 线程没有刷回磁盘之前，mysql 宕机重启之后是如何判断，在 redo log 中那些数据是需要恢复的呢？"
				}
			]
		},
		{
			"ID": "20210708003626-u9e13po",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-u9e13po"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有个 LSN 类似序列号，磁盘和 redolog 上面都有这个 LSN，如果当前 redolog LSN 存在但是磁盘不存在，说明就是需要恢复的"
				}
			]
		},
		{
			"ID": "20210708003626-ec9qtsl",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-ec9qtsl"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "思考题：为什么要保证 redo log 和 binlog 数据一致性"
				}
			]
		},
		{
			"ID": "20210708003626-3xi2r1p",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-3xi2r1p"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "因为 innodb 是作为一个插件独立于 mysql 的，不一致，就说明数据出错了"
				}
			]
		},
		{
			"ID": "20210708003626-7s21tu7",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210708003626-7s21tu7"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "Buffer Pool"
				}
			]
		},
		{
			"ID": "20210708003626-7siqwwg",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-7siqwwg"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "简介"
				}
			]
		},
		{
			"ID": "20210708003626-2egqla4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-2egqla4"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Buffer Pool 是属于 InnoDB 特有的组件，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "对于数据的所有操作都是在 Buffer Pool 中进行的"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。其默认大小（占用内存）是 128MB，可以通过如下系统变量修改"
				}
			]
		},
		{
			"ID": "20210708003626-5jwbn0g",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210708003626-5jwbn0g"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "[server]\ninnodb_buffer_pool_size = 2147483648\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210708003626-dt8t0u7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-dt8t0u7"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上述配置代表给 Buffer Pool 配置了 2GB 内存大小。"
				}
			]
		},
		{
			"ID": "20210708003626-1cxdcnd",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-1cxdcnd"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "数据页 == 缓存页 == 索引页"
				}
			]
		},
		{
			"ID": "20210708003626-l4qw5oi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-l4qw5oi"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Buffer Pool 中加载的数据结构是什么样子的？数据库的核心数据模型就是表+字段+行的概念。这里就不得不提到 MySQL "
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "抽象"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "出来的概念——数据页，其默认大小为 16KB（即可以存储 16KB 大小的数据，所以实际表一个数据页可以存储多个行数据呢？），与操作系统页大小不同哦。"
				}
			]
		},
		{
			"ID": "20210708003626-pxnh40m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-pxnh40m"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在操作数据时，数据库找到该行数据所在的数据页，并将该页加载到 Buffer Pool 中。加载到 Buffer Pool 中的数据页也被称为缓存页，两者此时完全一致。"
				}
			]
		},
		{
			"ID": "20210708003626-xjta05d",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-xjta05d"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "缓存页的描述信息"
				}
			]
		},
		{
			"ID": "20210708003626-0x06auy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-0x06auy"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对于每个缓存页都会有一个描述信息，用来描述这个缓存页的。如：这个数据页所属的表空间、数据页的编号、这个缓存页在 Buffer Pool 中的地址等等。"
				}
			]
		},
		{
			"ID": "20210708003626-uelf9f3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-uelf9f3"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "每个缓存页都会对应一个描述信息，这个描述信息本身也是一块数据，在 Buffer Pool 中，每个缓存页的描述数据放在最前面，然后各个缓存页放在后面。"
				}
			]
		},
		{
			"ID": "20210708003626-67oa4y1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-67oa4y1"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "注意一点，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "Buffer Pool 中的描述数据大概相当于缓存页大小的 5%左右"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，也就是每个缓存页的描述数据大概是 800 个字节左右的大小，然后假设你设置的 buffer pool 大小是 128MB，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "实际上 Buffer Pool 真正的最终大小会超出一些"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，可能有个 130 多 MB 的样子，因为他里面还要存放每个缓存页的描述数据。"
				}
			]
		},
		{
			"ID": "20210708003626-din41cs",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-din41cs"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "数据库启动时，初始化 Buffer Pool"
				}
			]
		},
		{
			"ID": "20210708003626-ent7gxz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-ent7gxz"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "数据库只要一启动，就会按照你设置的 Buffer Pool 大小，稍微再加大一点（因为要加上描述信息），去找操作系统申请一块内存区域，作为 Buffer Pool 的内存区域。"
				}
			]
		},
		{
			"ID": "20210708003626-s0affsq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-s0affsq"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后当内存区域申请完毕之后，数据库就会按照默认的缓存页的 16KB 的大小以及对应的 800 个字节左右的描述数据的大小，在 Buffer Pool 中划分出来一个一个的缓存页和一个一个的他们对应的描述数据。"
				}
			]
		},
		{
			"ID": "20210708003626-0efmftf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-0efmftf"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!"
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "["
						},
						{
							"Type": "NodeLinkText",
							"Data": "image.png"
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]"
						},
						{
							"Type": "NodeOpenParen",
							"Data": "("
						},
						{
							"Type": "NodeLinkDest",
							"Data": "../assets/buffer-pool.png"
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")"
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-ekktep3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-ekktep3"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "只不过这个时候，Buffer Pool 中的一个一个的缓存页都是空的，里面什么都没有，要等数据库运行起来之后，当我们要对数据执行增删改查的操作的时候，才会把数据对应的页从磁盘文件里读取出来，放入 Buffer Pool 中的缓存页中"
				}
			]
		},
		{
			"ID": "20210708003626-cemxynh",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-cemxynh"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "从磁盘加载数据页时哪些缓存页是空的？free 双向链表"
				}
			]
		},
		{
			"ID": "20210708003626-znofmxd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-znofmxd"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "默认情况下磁盘上的数据页和缓存页是一 一对应起来的，都是 16KB，一个数据页对应一个缓存页。所以我们必须要知道 Buffer Pool 中哪些缓存页是空闲的状态。"
				}
			]
		},
		{
			"ID": "20210708003626-nid76b9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-nid76b9"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "所以数据库会为 Buffer Pool 设计一个"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "free 链表"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，他是一个"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "双向链表"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "数据结构，这个 free 链表里，每个节点就是一个空闲的缓存页的"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "描述数据块的地址"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，也就是说，只要你一个"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "缓存页是空闲的，那么他的描述数据块就会被放入这个 free 链表"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "中。"
				}
			]
		},
		{
			"ID": "20210708003626-m892zfo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-m892zfo"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "刚开始数据库启动的时候，可能所有的缓存页都是空闲的，因为此时可能是一个空的数据库，一条数据都没有，所以"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "此时所有缓存页的描述数据块，都会被放入这个 free 链表中"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-bgkitrs",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-bgkitrs"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个 free 链表还有一个"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "基础节点"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，他会"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "引用链表的头节点和尾节点"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，里面还存储了链表中有多少个描述数据块的节点，也就是有"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "多少个空闲的缓存页"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210708003626-mdrpoe3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-mdrpoe3"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeImage",
							"Children": [
								{
									"Type": "NodeBang",
									"Data": "!"
								},
								{
									"Type": "NodeOpenBracket",
									"Data": "["
								},
								{
									"Type": "NodeLinkText",
									"Data": "image.png"
								},
								{
									"Type": "NodeCloseBracket",
									"Data": "]"
								},
								{
									"Type": "NodeOpenParen",
									"Data": "("
								},
								{
									"Type": "NodeLinkDest",
									"Data": "../assets/free-linked-table.png"
								},
								{
									"Type": "NodeCloseParen",
									"Data": ")"
								}
							]
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-d6qb04z",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-d6qb04z"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "free 链表占用额外多少内存？"
				}
			]
		},
		{
			"ID": "20210708003626-eckfkhx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-eckfkhx"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "看上图我们会以为以为这个描述数据块，在 Buffer Pool 里有一份，在 free 链表里也有一份，好像在内存里有两个一模一样的描述数据块，是么？错！"
				}
			]
		},
		{
			"ID": "20210708003626-uocixmi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-uocixmi"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其实这个 free 链表，他本身其实就是由 Buffer Pool 里的描述数据块组成的，你可以认为是每个描述数据块里都有两个指针，一个是 free_pre，一个是 free_next，分别指向自己的上一个 free 链表的节点，以及下一个 free 链表的节点。"
				}
			]
		},
		{
			"ID": "20210708003626-5bwuhr1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-5bwuhr1"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过 Buffer Pool 中的描述数据块的 free_pre 和 free_next 两个指针，就可以把所有的描述数据块串成一个 free 链表。上面为了画图需要，所以把描述数据块单独画了一份出来，表示他们之间的指针引用关系。"
				}
			]
		},
		{
			"ID": "20210708003626-pomqxsu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-pomqxsu"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "对于 free 链表而言，只有一个"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "基础节点是不属于 Buffer Pool 的"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，他是"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "40 字节"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "大小的一个节点，里面就存放了 free 链表的头节点的地址，尾节点的地址，还有 free 链表里当前有多少个节点。"
				}
			]
		},
		{
			"ID": "20210708003626-cmj8gep",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210708003626-cmj8gep"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "思考"
				}
			]
		},
		{
			"ID": "20210708003626-j3zqfuj",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210708003626-j3zqfuj"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "#### "
				},
				{
					"Type": "NodeText",
					"Data": "内存碎片的问题"
				}
			]
		},
		{
			"ID": "20210708003626-8gylxp0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-8gylxp0"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "大家可以想象一下，对于 Buffer Pool 而言，他里面会存放很多的缓存页以及对应的描述数据，那么假设 Buffer Pool 里的内存都用尽了，已经没有足够的剩余内存来存放缓存页和描述数据了，此时 Buffer Pool 里就一点内存都没有了吗？还是说 Buffer Pool 里会残留一些内存碎片呢？"
				}
			]
		},
		{
			"ID": "20210708003626-g3v66u8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-g3v66u8"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果你觉得 Buffer Pool 里会有内存碎片的话，那么你觉得应该怎么做才能尽可能减少 Buffer Pool 里的内存碎片呢？"
				}
			]
		},
		{
			"ID": "20210708003626-8hxzha2",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1,
				"Tight": true,
				"Start": 1,
				"Delimiter": 46,
				"Padding": 3,
				"Marker": "MQ==",
				"Num": 1
			},
			"Properties": {
				"id": "20210708003626-8hxzha2"
			},
			"Children": [
				{
					"ID": "20210708003626-rv6cicr",
					"Type": "NodeListItem",
					"Data": "1",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 1,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "MQ==",
						"Num": 1
					},
					"Properties": {
						"id": "20210708003626-rv6cicr"
					},
					"Children": [
						{
							"ID": "20210708003626-51nf8be",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-51nf8be"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "buffer_pool 的 size，是仅仅包含缓存页的大小，不包含描述数据的大小吧？"
								}
							]
						}
					]
				},
				{
					"ID": "20210708003626-aea3l1k",
					"Type": "NodeListItem",
					"Data": "2",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 2,
						"Delimiter": 46,
						"Padding": 3,
						"Marker": "Mg==",
						"Num": 2
					},
					"Properties": {
						"id": "20210708003626-aea3l1k"
					},
					"Children": [
						{
							"ID": "20210708003626-n8cw8k0",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210708003626-n8cw8k0"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如果在最后 buffer_pool 的内存使用完毕，则说明缓存页的的内存使用完毕，可以采取 LRU 的多种策略淘汰掉一些缓存页，重新 Load 出想要的数据。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210708003626-4vbaamo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-4vbaamo"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "缓存页是存放在内存中，那么就需要内存管理机制，LRU 之类的。"
				}
			]
		},
		{
			"ID": "20210708003626-oc8gfhl",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210708003626-oc8gfhl"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "#### "
				},
				{
					"Type": "NodeText",
					"Data": "Buffer Pool 和查询缓存区别"
				}
			]
		},
		{
			"ID": "20210708003626-q5owatr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-q5owatr"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里的 Buffer Pool 和查询缓存不是一回事，Buffer Pool 是用于增删改查的，而查询缓存只用于缓存查询数据，"
				}
			]
		},
		{
			"ID": "20210708003626-q6kperm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-q6kperm"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "查询缓存是针对单个表的，且只能读，如果这个表发生了增删改操作，该表的 sqlcache 全部要清空，mysql8 之后移除了这玩意。buffer pool 是数据缓存，基于他要做增删改查，提高速度"
				}
			]
		},
		{
			"ID": "20210708003626-8vuz2ah",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-8vuz2ah"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "直接看 mysql 的源文件，show varialbles like '%datadir%';就可以看到每个库下面每个表有一个 ibd 文件，这个就是表空间的文件，数据页只是在里面的一个单元而已，并不是单独的磁盘文件"
				}
			]
		},
		{
			"ID": "20210708003626-dqy7vr5",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210708003626-dqy7vr5"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "#### "
				},
				{
					"Type": "NodeText",
					"Data": "Buffer Pool 大小设置"
				}
			]
		},
		{
			"ID": "20210708003626-xh24qxd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-xh24qxd"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Buffer Pool 设置偏大的话如果宕机会丢失较多数据，checkpoint 游标来不及刷脏页，导致日志文件偏大，后续恢复时间偏长，有利有弊"
				}
			]
		},
		{
			"ID": "20210708003626-laef9km",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210708003626-laef9km"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我记得在 DBA 的课程上有介绍 innodb-buffer-pool-size 推荐设置到 70%-80% 的内存。然后我去 MySQL 5.7 的官网上查证了下，有写道：On a dedicated database server, you might set the buffer pool size to 80% of the machine's physical memory size. 链接：https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_buffer_pool_size"
				}
			]
		}
	]
}