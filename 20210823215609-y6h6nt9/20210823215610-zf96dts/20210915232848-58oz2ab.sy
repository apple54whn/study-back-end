{
	"ID": "20210915232848-58oz2ab",
	"Spec": "1",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20210915232848-58oz2ab",
		"title": "602.Entity 实体类详解（掌握）",
		"updated": "20210925215647"
	},
	"Children": [
		{
			"ID": "20210707235333-1mtbj99",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210707235333-1mtbj99",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Entity 实体是什么？"
				}
			]
		},
		{
			"ID": "20210707235333-k6l2n3d",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20210707235333-k6l2n3d",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"ID": "20210707235333-54ijwnc",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210707235333-54ijwnc"
					},
					"Children": [
						{
							"ID": "20210707235333-ybssdrf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-ybssdrf"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "实体是直接进行数据库持久化操作的领域对象（即一个简单的 POJO，可以按照业务领域划分），必须通过 @Entity 注解进行标示。"
								}
							]
						}
					]
				},
				{
					"ID": "20210707235333-5lx9bdm",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210707235333-5lx9bdm"
					},
					"Children": [
						{
							"ID": "20210707235333-f7h5oux",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-f7h5oux"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "实体必须有一个 public 或者 protected 的无参数构造方法。"
								}
							]
						}
					]
				},
				{
					"ID": "20210707235333-n184t1r",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210707235333-n184t1r"
					},
					"Children": [
						{
							"ID": "20210707235333-fdxb03l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-fdxb03l"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "持久化映射的注解可以标示在 Entity 的字段 field 上，也可以将持久化注解运用在 Entity 里面的 get/set 方法上，通常我们是放在 get 方法中。即 Entity 里面的注解生效只有两种方式：将注解写在字段上或者将注解写在方法上（JPA 里面称 Property）。但是"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "需要注意的是，在同一个 Entity 里面只能有一种方式生效"
								},
								{
									"Type": "NodeText",
									"Data": "，也就是说，注解要么全部写在 field 上面，要么就全部写在 Property 上面"
								}
							]
						}
					]
				},
				{
					"ID": "20210707235333-qwmsmjw",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210707235333-qwmsmjw"
					},
					"Children": [
						{
							"ID": "20210707235333-eev9p1l",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-eev9p1l"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "只要是在 @Entity 的实体里面被注解标注的字段，都会被映射到数据库中，除了使用 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "@Transient"
								},
								{
									"Type": "NodeText",
									"Data": " 注解的字段之外。"
								}
							]
						}
					]
				},
				{
					"ID": "20210707235333-7niy6e7",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210707235333-7niy6e7"
					},
					"Children": [
						{
							"ID": "20210707235333-suqbler",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-suqbler"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "实体里面"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "必须要有一个主键"
								},
								{
									"Type": "NodeText",
									"Data": "，主键标示的字段可以是单个字段，也可以是复合主键字段。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707235333-taqqx6u",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-taqqx6u",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "JPA 协议的官方地址：https://download.oracle.com/otn-pub/jcp/persistence-2_2-mrel-spec/JavaPersistence.pdf"
				}
			]
		},
		{
			"ID": "20210707235333-a4ngimf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-a4ngimf",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "利用 IEDA 工具，打开 @Entity 所在的包，就可以看到 JPA 里面支持的注解有哪些。如下所示；"
				}
			]
		},
		{
			"ID": "20210707235333-ovsppeq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-ovsppeq",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Data": "span",
					"Children": [
						{
							"Type": "NodeBang"
						},
						{
							"Type": "NodeOpenBracket"
						},
						{
							"Type": "NodeLinkText",
							"Data": "img"
						},
						{
							"Type": "NodeCloseBracket"
						},
						{
							"Type": "NodeOpenParen"
						},
						{
							"Type": "NodeLinkDest",
							"Data": "./assets/Ciqc1F9rLPSAFNw1AAQfaEA3Bgo587.png"
						},
						{
							"Type": "NodeCloseParen"
						}
					]
				}
			]
		},
		{
			"ID": "20210707235333-clodllu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-clodllu",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里只提及一些最常见的，包括 @Entity、@Table、@Access、@Id、@GeneratedValue、@Enumerated、@Basic、@Column、@Transient、@Lob、@Temporal 等。"
				}
			]
		},
		{
			"ID": "20210915233356-bo5xp4r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233356-bo5xp4r",
				"updated": "20210915233356"
			}
		},
		{
			"ID": "20210916225611-uommy94",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210916225611-uommy94",
				"updated": "20210916225611"
			}
		},
		{
			"ID": "20210916225612-0jez2n5",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210916225612-0jez2n5",
				"updated": "20210916225617"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "类"
				}
			]
		},
		{
			"ID": "20210707235333-30g8ixo",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-30g8ixo",
				"updated": "20210915233359"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Entity 🔥"
				}
			]
		},
		{
			"ID": "20210707235333-nteqvob",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-nteqvob",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "用于定义对象将会成为被 JPA 管理的实体，必填，将字段映射到指定的数据库表中，使用起来很简单，直接用在实体类上面即可，通过源码表达的语法如下："
				}
			]
		},
		{
			"ID": "20210707235333-lg58qtv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-lg58qtv",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Target(TYPE) //表示此注解只能用在class上面\npublic @interface Entity {\n   //可选，默认是实体类的名字，整个应用里面全局唯一。\n   String name() default \"\";\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210915233409-7c3sqxr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233409-7c3sqxr",
				"updated": "20210915233409"
			}
		},
		{
			"ID": "20210707235333-wuucmyu",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-wuucmyu",
				"updated": "20210915233412"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Table 🔥"
				}
			]
		},
		{
			"ID": "20210707235333-nnt549a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-nnt549a",
				"updated": "20210915233422"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "用于指定数据库的表名，表示此实体对应的数据库里面的表名，非必填，默认表名和 entity 名字一样。"
				}
			]
		},
		{
			"ID": "20210707235333-08kcy24",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-08kcy24",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Target(TYPE) //一样只能用在类上面\npublic @interface Table {\n   //表的名字，可选。如果不填写，系统认为好实体的名字一样为表名。\n   String name() default \"\";\n   //此表所在schema，可选\n   String schema() default \"\";\n   //唯一性约束，在创建表的时候有用，表创建之后后面就不需要了。\n   UniqueConstraint[] uniqueConstraints() default { };\n   //索引，在创建表的时候使用，表创建之后后面就不需要了。\n   Index[] indexes() default {};\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210915233427-x6ptqcq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233427-x6ptqcq",
				"updated": "20210915233427"
			}
		},
		{
			"ID": "20210707235333-j55ttrw",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-j55ttrw",
				"updated": "20210915234006"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "实体之间的继承关系🔥"
				}
			]
		},
		{
			"ID": "20210707235333-36m7chu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-36m7chu",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在 Java 面向对象的语言环境中，@Entity 之间的关系多种多样，而根据 JPA 的规范，我们大致可以将其分为以下几种："
				}
			]
		},
		{
			"ID": "20210707235333-azzg2hu",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20210707235333-azzg2hu",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"ID": "20210707235333-591dh03",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20210707235333-591dh03"
					},
					"Children": [
						{
							"ID": "20210707235333-75g8ib5",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-75g8ib5"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "纯粹的继承，和表没关系，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "对象之间的字段共享"
								},
								{
									"Type": "NodeText",
									"Data": "。利用注解 "
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "@MappedSuperclass"
								},
								{
									"Type": "NodeText",
									"Data": "，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "协议规定父类不能是 @Entity"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						}
					]
				},
				{
					"ID": "20210707235333-kgdmt85",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20210707235333-kgdmt85"
					},
					"Children": [
						{
							"ID": "20210707235333-60frxuf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-60frxuf"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "单表多态问题，同一张 Table，表示了不同的对象，通过一个字段来进行区分。利用"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "@Inheritance(strategy = InheritanceType.SINGLE_TABLE)"
								},
								{
									"Type": "NodeText",
									"Data": "注解完成，只有父类有 @Table。"
								}
							]
						}
					]
				},
				{
					"ID": "20210707235333-zgvw8j9",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "My4=",
						"Num": 3
					},
					"Properties": {
						"id": "20210707235333-zgvw8j9"
					},
					"Children": [
						{
							"ID": "20210707235333-ptrea0o",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-ptrea0o"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "多表多态，每一个子类一张表，父类的表拥有所有公用字段。通过"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "@Inheritance(strategy = InheritanceType.JOINED)"
								},
								{
									"Type": "NodeText",
									"Data": "注解完成，父类和子类都是表，有公用的字段在父表里面。"
								}
							]
						}
					]
				},
				{
					"ID": "20210707235333-wuu7sq7",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "NC4=",
						"Num": 4
					},
					"Properties": {
						"id": "20210707235333-wuu7sq7"
					},
					"Children": [
						{
							"ID": "20210707235333-wnft9vc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-wnft9vc"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Object 的继承，数据库里面每一张表是分开的，相互独立不受影响。通过"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)"
								},
								{
									"Type": "NodeText",
									"Data": "注解完成，父类（可以是一张表，也可以不是）和子类都是表，相互之间没有关系。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210915234031-6a294gk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915234031-6a294gk",
				"updated": "20210915234031"
			}
		},
		{
			"ID": "20210707235333-qkeuxgd",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210707235333-qkeuxgd",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@MappedSuperclass 🔥"
				}
			]
		},
		{
			"ID": "20210707235333-d1mfmyj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-d1mfmyj",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其中，第一种 @MappedSuperclass，我们暂时不多介绍，在第 12 课时讲解“JPA 的审计功能”时，再做详细介绍，我们先看一下第二种"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "code",
					"TextMarkTextContent": "SINGLE_TABLE"
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210915232017-7dlyfup",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210915232017-7dlyfup",
				"updated": "20210925215647"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/**\n * abstract 这个类就是为了被继承\n * 这里三个字段无法被数据库映射到，且不能使用@Entity，但是JPA提供了@MappedSuperclass代表基类\n */\n@Getter\n@Setter\n@MappedSuperclass\npublic abstract class BaseEntity {\n\n    /** 可以使用数据库默认 CURRENT_TIMESTAMP 来自动填写。去掉根据当前时间戳更新！*/\n    private LocalDateTime createTime;\n\n    /** 可以使用数据库默认 CURRENT_TIMESTAMP 来自动填写。勾上根据当前时间戳更新！*/\n    @JsonIgnore\n    private LocalDateTime updateTime;\n\n    @JsonIgnore\n    private LocalDateTime deleteTime;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210915232017-wd2zl2w",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915232017-wd2zl2w",
				"updated": "20210915232017"
			}
		},
		{
			"ID": "20210915232017-7nabxme",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915232017-7nabxme",
				"updated": "20210915232017"
			}
		},
		{
			"ID": "20210707235333-4mfkl4k",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210707235333-4mfkl4k",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Inheritance(strategy = InheritanceType.SINGLE_TABLE)"
				}
			]
		},
		{
			"ID": "20210707235333-shro91b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-shro91b",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "父类实体对象与各个子实体对象共用一张表，通过一个字段的不同值代表不同的对象，我们看一个例子。"
				}
			]
		},
		{
			"ID": "20210707235333-9fwamkx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-9fwamkx",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们抽象一个 Book 对象，如下所示："
				}
			]
		},
		{
			"ID": "20210707235333-b6fqdzw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-b6fqdzw",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Entity(name=\"book\")\n@Data\n@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n@DiscriminatorColumn(name=\"color\", discriminatorType = DiscriminatorType.STRING)\npublic class Book {\n   @Id\n   @GeneratedValue(strategy= GenerationType.AUTO)\n   private Long id;\n   private String title;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-ir3fyre",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-ir3fyre",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "再新建一个 BlueBook 对象，作为 Book 的子对象。"
				}
			]
		},
		{
			"ID": "20210707235333-yt725nx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-yt725nx",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Entity\n@Data\n@EqualsAndHashCode(callSuper=false)\n@DiscriminatorValue(\"blue\")\npublic class BlueBook extends Book{\n   private String blueMark;\n}\n\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-9w00ko1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-9w00ko1",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "再新建一个 RedBook 对象，作为 Book 的另一子对象。"
				}
			]
		},
		{
			"ID": "20210707235333-pvh55mk",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-pvh55mk",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//红皮书\n@Entity\n@DiscriminatorValue(\"red\")\n@Data\n@EqualsAndHashCode(callSuper=false)\npublic class RedBook extends Book {\n   private String redMark;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-vvz8vtx",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-vvz8vtx",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这时，我们一共新建了三个 Entity 对象，其实都是指 book 这一张表，通过 book 表里面的 color 字段来区分红书还是绿书。我们继续做一下测试看看结果。"
				}
			]
		},
		{
			"ID": "20210707235333-7ejdzsq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-7ejdzsq",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们再新建一个 RedBookRepositor 类，操作一下 RedBook 会看到如下结果："
				}
			]
		},
		{
			"ID": "20210707235333-r9l7zqy",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-r9l7zqy",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public interface RedBookRepository extends JpaRepository\u003cRedBook,Long\u003e{\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-zlrahg4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-zlrahg4",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后再新建一个测试用例。"
				}
			]
		},
		{
			"ID": "20210707235333-o1ytwfk",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-o1ytwfk",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@DataJpaTest\npublic class RedBookRepositoryTest {\n   @Autowired\n   private RedBookRepository redBookRepository;\n   @Test\n   public void testRedBook() {\n      RedBook redBook = new RedBook();\n      redBook.setTitle(\"redbook\");\n      redBook.setRedMark(\"redmark\");\n      redBook.setId(1L);\n      redBookRepository.saveAndFlush(redBook);\n      RedBook r = redBookRepository.findById(1L).get();\n    System.out.println(r.getId()+\":\"+r.getTitle()+\":\"+r.getRedMark());\n   }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-jfdbr5d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-jfdbr5d",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "最后看一下执行结果。"
				}
			]
		},
		{
			"ID": "20210707235333-n67abld",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-n67abld",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Hibernate: create table book (color varchar(31) not null, id bigint not null, title varchar(255), blue_mark varchar(255), red_mark varchar(255), primary key (id))\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-v6xb41j",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-v6xb41j",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "你会发现，我们只创建了一张表，insert 了一条数据，但是我们发现 color 字段默认给的是 red。"
				}
			]
		},
		{
			"ID": "20210707235333-9zmhjgh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-9zmhjgh",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Hibernate: insert into book (title, red_mark, color, id) values (?, ?, 'red', ?)\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-ssi5lhd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-ssi5lhd",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那么再看一下打印结果。"
				}
			]
		},
		{
			"ID": "20210707235333-mw814s1",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-mw814s1",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "1:redbook:redmark\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-xif9ewy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-xif9ewy",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "结果完全和预期的一样，这说明了 RedBook、BlueBook、Book，都是一张表，通过字段 color 的值不一样，来区分不同的实体。\n那么接下来我们看一下 InheritanceType.JOINED，它的每个实体都是独立的表。"
				}
			]
		},
		{
			"ID": "20210707235333-pinepam",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210707235333-pinepam",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Inheritance(strategy = InheritanceType.JOINED)"
				}
			]
		},
		{
			"ID": "20210707235333-jlt1wu3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-jlt1wu3",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在这种映射策略里面，继承结构中的每一个实体（entity）类都会映射到数据库里一个单独的表中。也就是说，每个实体（entity）都会被映射到数据库中，一个实体（entity）类对应数据库中的一个表。"
				}
			]
		},
		{
			"ID": "20210707235333-uenoe5h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-uenoe5h",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其中根实体（root entity）对应的表中定义了主键（primary key），所有的子类对应的数据库表都要共同使用 Book 里面的 @ID 这个主键。"
				}
			]
		},
		{
			"ID": "20210707235333-ciwnm5y",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-ciwnm5y",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，我们改一下上面的三个实体，测试一下 InheritanceType.JOINED，改动如下："
				}
			]
		},
		{
			"ID": "20210707235333-tgi8fi9",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-tgi8fi9",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Entity(name=\"book\")\n@Data\n@Inheritance(strategy = InheritanceType.JOINED)\npublic class Book {\n   @Id\n   @GeneratedValue(strategy= GenerationType.AUTO)\n   private Long id;\n   private String title;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-nz1jm3h",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-nz1jm3h",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其次，我们 Book 父类、改变 Inheritance 策略、删除 DiscriminatorColumn，你会看到如下结果。"
				}
			]
		},
		{
			"ID": "20210707235333-co0tk51",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-co0tk51",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Entity\n@Data\n@EqualsAndHashCode(callSuper=false)\n@PrimaryKeyJoinColumn(name = \"book_id\", referencedColumnName = \"id\")\npublic class BlueBook extends Book{\n   private String blueMark;\n}\n\n\n@Entity\n@PrimaryKeyJoinColumn(name = \"book_id\", referencedColumnName = \"id\")\n@Data\n@EqualsAndHashCode(callSuper=false)\npublic class RedBook extends Book {\n   private String redMark;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-sur7zf0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-sur7zf0",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后，BlueBook 和 RedBook 也删除 DiscriminatorColumn，新增@PrimaryKeyJoinColumn(name = \"book_id\", referencedColumnName = \"id\")，和 book 父类共用一个主键值，而 RedBookRepository 和测试用例不变，我们执行看一下结果。"
				}
			]
		},
		{
			"ID": "20210707235333-96wlxnw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-96wlxnw",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Hibernate: create table blue_book (blue_mark varchar(255), book_id bigint not null, primary key (book_id))\nHibernate: create table book (id bigint not null, title varchar(255), primary key (id))\nHibernate: create table red_book (red_mark varchar(255), book_id bigint not null, primary key (book_id))\nHibernate: alter table blue_book add constraint FK9uuwgq7a924vtnys1rgiyrlk7 foreign key (book_id) references book\nHibernate: alter table red_book add constraint FKk8rvl61bjy9lgsr9nhxn5soq5 foreign key (book_id) references book\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-jppm4v2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-jppm4v2",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "上述代码可以看到，我们一共创建了三张表，并且新增了两个外键约束；而我们 save 的时候也生成了两个 insert 语句，如下："
				}
			]
		},
		{
			"ID": "20210707235333-c56zllh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-c56zllh",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "ag=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Hibernate: insert into book (title, id) values (?, ?)\nHibernate: insert into red_book (red_mark, book_id) values (?, ?)\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-oq8cwf2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-oq8cwf2",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "而打印结果依然不变。"
				}
			]
		},
		{
			"ID": "20210707235333-t6um3lv",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-t6um3lv",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "1:redbook:redmark\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-xqj1ite",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-xqj1ite",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这就是 InheritanceType.JOINED 的例子，这个方法和上面的 InheritanceType.SINGLE_TABLE 区别在于表的数量和关系不一样，这是表设计的另一种方式。"
				}
			]
		},
		{
			"ID": "20210707235333-ohz0by7",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210707235333-ohz0by7",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS) 🔥"
				}
			]
		},
		{
			"ID": "20210707235333-f6d94ni",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-f6d94ni",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们在使用 @MappedSuperClass 主键的时候，如果不指定 @Inhertance，默认就是此种 TABLE_PER_CLASS 模式。当然了，我们也显示指定，要求继承基类的都是一张表，而父类不是表，是 java 对象的抽象类。我们看一个例子。"
				}
			]
		},
		{
			"ID": "20210707235333-ens2dun",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-ens2dun",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "首先，还是改一下上面的三个实体。"
				}
			]
		},
		{
			"ID": "20210707235333-5kvhhv8",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-5kvhhv8",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Entity(name=\"book\")\n@Data\n@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)\npublic class Book {\n   @Id\n   @GeneratedValue(strategy= GenerationType.AUTO)\n   private Long id;\n   private String title;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-alpemot",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-alpemot",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其次，Book 表采用 TABLE_PER_CLASS 策略，其子实体类都代表各自的表，实体代码如下："
				}
			]
		},
		{
			"ID": "20210707235333-qqz7cmp",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-qqz7cmp",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Entity\n@Data\n@EqualsAndHashCode(callSuper=false)\npublic class RedBook extends Book {\n   private String redMark;\n}\n\n\n@Entity\n@Data\n@EqualsAndHashCode(callSuper=false)\npublic class BlueBook extends Book{\n   private String blueMark;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-ql67szi",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-ql67szi",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这时，从 RedBook 和 BlueBook 里面去掉 PrimaryKeyJoinColumn，而 RedBookRepository 和测试用例不变，我们执行看一下结果。"
				}
			]
		},
		{
			"ID": "20210707235333-vokc9bx",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-vokc9bx",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Hibernate: create table blue_book (id bigint not null, title varchar(255), blue_mark varchar(255), primary key (id))\nHibernate: create table book (id bigint not null, title varchar(255), primary key (id))\nHibernate: create table red_book (id bigint not null, title varchar(255), red_mark varchar(255), primary key (id))\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-2kh1pol",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-2kh1pol",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这里可以看到，我们还是创建了三张表，但三张表什么关系也没有。而 insert 语句也只有一条，如下："
				}
			]
		},
		{
			"ID": "20210707235333-cfeufly",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-cfeufly",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Hibernate: insert into red_book (title, red_mark, id) values (?, ?, ?)\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-g6vqft9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-g6vqft9",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "打印结果还是不变。"
				}
			]
		},
		{
			"ID": "20210707235333-2vi268w",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-2vi268w",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "1:redbook:redmark\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-634bca9",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-634bca9",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个方法与上面两个相比较，语义更加清晰，是比较常用的一种做法。\n以上就是实体之间继承关系的实现方法，可以在涉及 java 多态的时候加以应用，不过要注意区分三种方式所表达的表的意思，再加以运用。"
				}
			]
		},
		{
			"ID": "20210707235333-dj0baan",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210707235333-dj0baan",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "关于继承关系的经验之谈—@Inheritance 被淘汰 🔥"
				}
			]
		},
		{
			"ID": "20210707235333-4x5dps2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-4x5dps2",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "从我的个人经验来看，@Inheritance 的这种使用方式会逐渐被淘汰，因为这样的表的设计很复杂，本应该在业务层面做的事情（多态），而在 datasoure 的表级别做了。所以在 JPA 中使用这个的时候你就会想：“这么复杂的东西，我直接用 Mybatis 算了。”我想告诉你，其实它们是一样的，只是我们使用的思路不对。"
				}
			]
		},
		{
			"ID": "20210707235333-ti3wqb0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-ti3wqb0",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那么为什么行业内都不建议使用了，还要介绍这么详细呢？因为，如果你遇到的是老一点的项目，如果不是用 Java 语言写的，不一定有面向对象的思想。这个时候如果让你迁移成 Java 怎么办？如果你可以想到这种用法，就不至于束手无措。"
				}
			]
		},
		{
			"ID": "20210707235333-aakreu2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-aakreu2",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "此外，在互联网项目中，一旦有关表的业务对象过多了之后，就可以拆表拆库了，这个时候我们要想到我们的@Table 注解指定表名和 schema。"
				}
			]
		},
		{
			"ID": "20210707235333-lu76fym",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-lu76fym",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "关于上面提到的方法中，最常用的是第一种 @MappedSuperclass，这个我们将在第 12 课时“JPA 的审计功能解决了哪些问题？”中详细介绍，到时候你可以体验一下它的不同之处。"
				}
			]
		},
		{
			"ID": "20210915233842-t4l5xy5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233842-t4l5xy5",
				"updated": "20210915233842"
			}
		},
		{
			"ID": "20210916225703-bcuxme1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210916225703-bcuxme1",
				"updated": "20210916225703"
			}
		},
		{
			"ID": "20210916225848-re9vadz",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210916225848-re9vadz",
				"updated": "20210916225946"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Where 🔥"
				}
			]
		},
		{
			"ID": "20210916225850-o91i1ud",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210916225850-o91i1ud",
				"updated": "20210916225912"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Where(clause = \"delete_time is null\")\npublic class Banner extends BaseEntity {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    /* 名称，对无意义id的描述 */\n    private String name;\n\n    /* 可以展示到前端的 */\n    private String title;\n    private String description;\n    private String img;\n\n\n    @OneToMany\n    @JoinColumn(name = \"bannerId\")\n    private List\u003cBannerItem\u003e itemList;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210916225848-zk7nzs5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210916225848-zk7nzs5",
				"updated": "20210916225848"
			}
		},
		{
			"ID": "20210916225848-vlpbgjb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210916225848-vlpbgjb",
				"updated": "20210916225848"
			}
		},
		{
			"ID": "20210916225703-c2lvllr",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210916225703-c2lvllr",
				"updated": "20210916225720"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "列"
				}
			]
		},
		{
			"ID": "20210707235333-uc13jut",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-uc13jut",
				"updated": "20210915233520"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Id \u0026 @GeneratedValue 🔥"
				}
			]
		},
		{
			"ID": "20210915233529-tweuyzf",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210915233529-tweuyzf",
				"updated": "20210915233530"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Id"
				}
			]
		},
		{
			"ID": "20210707235333-qntv9zc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-qntv9zc",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "定义属性为数据库的主键，一个实体里面必须有一个主键，但不一定是这个注解，可以和 @GeneratedValue 配合使用或成对出现。"
				}
			]
		},
		{
			"ID": "20210707235333-l4c1snr",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210707235333-l4c1snr",
				"updated": "20210915233536"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@GeneratedValue"
				}
			]
		},
		{
			"ID": "20210707235333-gi7idxb",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-gi7idxb",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "主键生成策略，如下所示："
				}
			]
		},
		{
			"ID": "20210707235333-o1j6a3k",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-o1j6a3k",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public @interface GeneratedValue {\n    //Id的生成策略\n    GenerationType strategy() default AUTO;\n    //通过Sequences生成Id,常见的是Orcale数据库ID生成规则，这个时候需要配合@SequenceGenerator使用\n    String generator() default \"\";\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-u610248",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-u610248",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其中，GenerationType 一共有以下四个值："
				}
			]
		},
		{
			"ID": "20210707235333-4vkgxx1",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-4vkgxx1",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public enum GenerationType {\n    //通过表产生主键，框架借由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植。\n    TABLE,\n    //通过序列产生主键，通过 @SequenceGenerator 注解指定序列名， MySql 不支持这种方式；\n    SEQUENCE,\n    //采用数据库ID自增长， 一般用于mysql数据库\n    IDENTITY,\n//JPA 自动选择合适的策略，是默认选项；\n    AUTO\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210915233452-2p3ci36",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233452-2p3ci36",
				"updated": "20210915233452"
			}
		},
		{
			"ID": "20210915233501-9edqdbt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233501-9edqdbt",
				"updated": "20210915233501"
			}
		},
		{
			"ID": "20210707235333-xujvdmt",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-xujvdmt",
				"updated": "20210915233638"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Column 🔥"
				}
			]
		},
		{
			"ID": "20210707235333-cjbbu38",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-cjbbu38",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "定义该属性对应数据库中的列名。"
				}
			]
		},
		{
			"ID": "20210707235333-ymk7woo",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-ymk7woo",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public @interface Column {\n    //数据库中的表的列名；可选，如果不填写认为字段名和实体属性名一样。\n    String name() default \"\";\n    //是否唯一。默认flase，可选。\n    boolean unique() default false;\n    //数据字段是否允许空。可选，默认true。\n    boolean nullable() default true;\n    //执行insert操作的时候是否包含此字段，默认，true，可选。\n    boolean insertable() default true;\n    //执行update的时候是否包含此字段，默认，true，可选。\n    boolean updatable() default true;\n    //表示该字段在数据库中的实际类型。\n    String columnDefinition() default \"\";\n   //数据库字段的长度，可选，默认255\n    int length() default 255;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210915233621-5wghwfq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233621-5wghwfq",
				"updated": "20210915233621"
			}
		},
		{
			"ID": "20210915233607-qx1zqbp",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233607-qx1zqbp",
				"updated": "20210915233607"
			}
		},
		{
			"ID": "20210915233648-2zsu23v",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210915233648-2zsu23v",
				"updated": "20210915233702"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Basic \u0026 @Transient 🔥"
				}
			]
		},
		{
			"ID": "20210707235333-g4v1kvo",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210707235333-g4v1kvo",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Basic"
				}
			]
		},
		{
			"ID": "20210707235333-3mh9xvr",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-3mh9xvr",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "表示属性是到数据库表的字段的映射。如果实体的字段上没有任何注解，默认即为 @Basic。也就是说默认所有的字段肯定是和数据库进行映射的，并且默认为 Eager 类型。"
				}
			]
		},
		{
			"ID": "20210707235333-4qmtvg2",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-4qmtvg2",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public @interface Basic {\n    //可选，EAGER（默认）：立即加载；LAZY：延迟加载。（LAZY主要应用在大字段上面）\n    FetchType fetch() default EAGER;\n    //可选。这个字段是否可以为null，默认是true。\n    boolean optional() default true;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-oefegye",
			"Type": "NodeHeading",
			"HeadingLevel": 4,
			"Properties": {
				"id": "20210707235333-oefegye",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Transient"
				}
			]
		},
		{
			"ID": "20210707235333-rhtg5gu",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-rhtg5gu",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "表示该属性并非一个到数据库表的字段的映射，表示非持久化属性。JPA 映射数据库的时候忽略它，与 @Basic 有相反的作用。也就是每个字段上面 @Transient 和 @Basic 必须二选一，而什么都不指定的话，默认是 @Basic。"
				}
			]
		},
		{
			"ID": "20210915233608-runsw4f",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233608-runsw4f",
				"updated": "20210915233608"
			}
		},
		{
			"ID": "20210707235333-hobu7ie",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-hobu7ie",
				"updated": "20210915234301"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Temporal 🔥"
				}
			]
		},
		{
			"ID": "20210707235333-858aqxt",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-858aqxt",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "用来设置 Date 类型的属性映射到对应精度的字段，存在以下三种情况："
				}
			]
		},
		{
			"ID": "20210707235333-94rdxtt",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20210707235333-94rdxtt",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"ID": "20210707235333-8zflsc4",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210707235333-8zflsc4"
					},
					"Children": [
						{
							"ID": "20210707235333-k4gdegk",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-k4gdegk"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "@Temporal(TemporalType.DATE)映射为日期 // date （"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "只有日期"
								},
								{
									"Type": "NodeText",
									"Data": "）"
								}
							]
						}
					]
				},
				{
					"ID": "20210707235333-mspazjy",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210707235333-mspazjy"
					},
					"Children": [
						{
							"ID": "20210707235333-sy8y8tc",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-sy8y8tc"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "@Temporal(TemporalType.TIME)映射为日期 // time （"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "只有时间"
								},
								{
									"Type": "NodeText",
									"Data": "）"
								}
							]
						}
					]
				},
				{
					"ID": "20210707235333-krk5h1p",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210707235333-krk5h1p"
					},
					"Children": [
						{
							"ID": "20210707235333-rhgixwx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-rhgixwx"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "@Temporal(TemporalType.TIMESTAMP)映射为日期 // date time （"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "日期+时间"
								},
								{
									"Type": "NodeText",
									"Data": "）"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210915233725-dwrmitg",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233725-dwrmitg",
				"updated": "20210915233725"
			}
		},
		{
			"ID": "20210915234333-tp627jq",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210915234333-tp627jq",
				"updated": "20210915234333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Lob"
				}
			]
		},
		{
			"ID": "20210915234335-a8700ni",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915234335-a8700ni",
				"updated": "20210915234410"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "指定持久属性或字段应作为大对象持久化到数据库支持的大对象类型"
				}
			]
		},
		{
			"ID": "20210915233502-aia8y0g",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233502-aia8y0g",
				"updated": "20210915233502"
			}
		},
		{
			"ID": "20210707235333-ubp8sbi",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-ubp8sbi",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Access"
				}
			]
		},
		{
			"ID": "20210707235333-yzu61ot",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-yzu61ot",
				"updated": "20210915233435"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "用于指定 entity 里面的"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "注解是写在字段上面，还是 get/set 方法上面生效"
				},
				{
					"Type": "NodeText",
					"Data": "，非必填。在默认不填写的情况下，当实体里面的第一个注解出现在字段上或者 get/set 方法上面，就以第一次出现的方式为准；也就是说，一个实体里面的注解既有用在 field 上面，又有用在 properties 上面的时候，看下面的代码你就会明白。"
				}
			]
		},
		{
			"ID": "20210707235333-vt5s9uo",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-vt5s9uo",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Id\nprivate Long id;\n@Column(length = 20, nullable = false)\npublic String getUserName(){\n    return userName;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-nfksja0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-nfksja0",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "那么由于 @Id 是实体里面第一个出现的注解，并且作用在字段上面，所以所有写在 get/set 方法上面的注解就会失效。而 @Access 可以干预默认值，指定是在 fileds 上面生效还是在 properties 上面生效。我们通过源码看下语法："
				}
			]
		},
		{
			"ID": "20210707235333-9vh80k6",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-9vh80k6",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Target( { TYPE, METHOD, FIELD })//表示此注解可以运用在class上(那么这个时候就可以指定此实体的默认注解生效策略了)，也可以用在方法上或者字段上(表示可以独立设置某一个字段或者方法的生效策略)；\n@Retention(RUNTIME)\npublic @interface Access {\n//指定是字段上面生效还是方法上面生效\n    AccessType value();\n}\npublic enum AccessType {\n    FIELD,\n    PROPERTY\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210915233440-sew43h6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233440-sew43h6",
				"updated": "20210915233440"
			}
		},
		{
			"ID": "20210707235333-ruqedva",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-ruqedva",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Enumerated（没啥用）"
				}
			]
		},
		{
			"ID": "20210707235333-xy46r7n",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-xy46r7n",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这个注解很不好用，因为它对 enum 提供了下标和 name 两种方式，用法直接映射在 enum 枚举类型的字段上。请看下面源码。"
				}
			]
		},
		{
			"ID": "20210707235333-ejp2l2k",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-ejp2l2k",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Target({METHOD, FIELD}) //作用在方法和字段上\npublic @interface Enumerated {\n//枚举映射的类型，默认是ORDINAL（即枚举字段的下标）。\n    EnumType value() default ORDINAL;\n}\npublic enum EnumType {\n    //映射枚举字段的下标\n    ORDINAL,\n    //映射枚举的Name\n    STRING\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-ufzwcxy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-ufzwcxy",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "再来看一个 User 里面关于性别枚举的例子，你就会知道 @Enumerated 在这里"
				},
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "没什么作用了"
				},
				{
					"Type": "NodeText",
					"Data": "，如下所示："
				}
			]
		},
		{
			"ID": "20210707235333-mmnw85c",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-mmnw85c",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//有一个枚举类，用户的性别\npublic enum Gender {\n    MAIL(\"男性\"), FMAIL(\"女性\");\n    private String value;\n    private Gender(String value) {\n        this.value = value;\n    }\n}\n//实体类@Enumerated的写法如下\n@Entity\n@Table(name = \"tb_user\")\npublic class User implements Serializable {\n    @Enumerated(EnumType.STRING)\n    @Column(name = \"user_gender\")\n    private Gender gender;\n    //.......................\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-pkm19xa",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-pkm19xa",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "这时候插入两条数据，数据库里面的值会变成 MAIL/FMAIL，而不是“男性” / 女性。"
				}
			]
		},
		{
			"ID": "20210707235333-mjjh1ah",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-mjjh1ah",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeTextMark",
					"TextMarkType": "strong",
					"TextMarkTextContent": "经验分享："
				},
				{
					"Type": "NodeText",
					"Data": " 如果我们用 @Enumerated（EnumType.ORDINAL），这时候数据库里面的值是 0、1。但是实际工作中，不建议用数字下标，因为枚举里面的属性值是会不断新增的，如果新增一个，位置变化了就惨了。并且 0、1、2 这种下标在数据库里面看着非常痛苦，时间长了就会一点也看不懂了。"
				}
			]
		},
		{
			"ID": "20210915233553-koewjco",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233553-koewjco",
				"updated": "20210915233553"
			}
		},
		{
			"ID": "20210707235333-kt18v5l",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-kt18v5l",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "完整的例子"
				}
			]
		},
		{
			"ID": "20210707235333-jioxlpa",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-jioxlpa",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Entity\n@Table(name = \"user_topic\")\n@Access(AccessType.FIELD)\n@Data\npublic class UserTopic {\n   @Id\n   @Column(name = \"id\", nullable = false)\n   @GeneratedValue(strategy = GenerationType.IDENTITY)\n   private Integer id;\n   @Column(name = \"title\", nullable = true, length = 200)\n   private String title;\n   @Basic\n   @Column(name = \"create_user_id\", nullable = true)\n   private Integer createUserId;\n   @Basic(fetch = FetchType.LAZY)\n   @Column(name = \"content\", nullable = true, length = -1)\n   @Lob\n   private String content;\n   @Basic(fetch = FetchType.LAZY)\n   @Column(name = \"image\", nullable = true)\n   @Lob\n   private byte[] image;\n   @Basic\n   @Column(name = \"create_time\", nullable = true)\n   @Temporal(TemporalType.TIMESTAMP)\n   private Date createTime;\n   @Basic\n   @Column(name = \"create_date\", nullable = true)\n   @Temporal(TemporalType.DATE)\n   private Date createDate;\n   @Enumerated(EnumType.STRING)\n   @Column(name = \"topic_type\")\n   private Type type;\n   @Transient\n   private String transientSimple;\n   //非数据库映射字段，业务类型的字段\n   public String getTransientSimple() {\n      return title + \"auto:jack\" + type;\n   }\n   //有一个枚举类，主题的类型\n   public enum Type {\n      EN(\"英文\"), CN(\"中文\");\n      private final String des;\n      Type(String des) {\n         this.des = des;\n      }\n   }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-3tbmyh3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-3tbmyh3",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其实这里面的很多注解都可以省略，直接使用默认的就可以。如 @Basic、@Column 名字有一定的映射策略（我们在第 17 课时讲 DataSource 的时候会详细讲解映射策略），所以可以省略。此外，@Access 也可以省略，我们只要在这些类里面保持一致就可以了。"
				}
			]
		},
		{
			"ID": "20210707235333-t4bixf0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-t4bixf0",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "但是需要注意的是，在生产环境中我们要把外键关联关系关闭，不然会出现意想不到的 ERROR，毕竟生产环境不同开发环境，我们可以通过在开发环境生成的表导出 DDL 到生产执行。我经常会利用生成 DDL 来做测试和写案例， 这样省去了创建表的时间，只需要关注我的代码就行了。"
				}
			]
		},
		{
			"ID": "20210915230800-8w7p4t5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915230800-8w7p4t5",
				"updated": "20210915230800"
			}
		},
		{
			"ID": "20210915230804-8uuiy8i",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210915230804-8uuiy8i",
				"updated": "20210925202819"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "IDEA 生成 Entity 🔥"
				}
			]
		},
		{
			"ID": "20210925204957-5dcbze0",
			"Type": "NodeParagraph",
			"Properties": {
				"fold": "0",
				"id": "20210925204957-5dcbze0",
				"updated": "20210925205005"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "方式1：Database"
				}
			]
		},
		{
			"ID": "20210925202834-a9perio",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20210925202834-a9perio",
				"updated": "20210925215422"
			},
			"Children": [
				{
					"ID": "20210925203003-37bwljg",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210925203003-37bwljg"
					},
					"Children": [
						{
							"ID": "20210925203003-740wg7r",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210925203003-740wg7r",
								"updated": "20210925203005"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用 IDEA 自带的 Datebase 连接数据库后"
								}
							]
						}
					]
				},
				{
					"ID": "20210925203006-9owk14z",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210925203006-9owk14z",
						"updated": "20210925215422"
					},
					"Children": [
						{
							"ID": "20210925203006-h9m19kx",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210925203006-h9m19kx",
								"updated": "20210925203105"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在Database右键点击"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Scripted Extensions"
								},
								{
									"Type": "NodeText",
									"Data": "—\u003e"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Go To Scripts Directory"
								},
								{
									"Type": "NodeText",
									"Data": "，修改"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Generate_POJOs.groovy"
								}
							]
						},
						{
							"ID": "20210925203108-cb65nm3",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210925203108-cb65nm3",
								"updated": "20210925204904"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如：映射字段类型、getter、setter之类的。配置查询该"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "a",
									"TextMarkAHref": "https://xiao7.blog.csdn.net/article/details/104292797?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-7.no_search_link\u0026depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7Edefault-7.no_search_link",
									"TextMarkTextContent": "博客"
								},
								{
									"Type": "NodeText",
									"Data": "。"
								}
							]
						},
						{
							"ID": "20210925213652-jw4rgms",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"Properties": {
								"id": "20210925213652-jw4rgms",
								"updated": "20210925215422"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```"
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "import com.intellij.database.model.DasTable\nimport com.intellij.database.util.Case\nimport com.intellij.database.util.DasUtil\n\n/*\n * Available context bindings:\n *   SELECTION   Iterable\u003cDasObject\u003e\n *   PROJECT     project\n *   FILES       files helper\n */\n\npackageName = \"top.conanan.model;\"\nimportName = \n        \"import lombok.*;\\n\" +\n        \"\\n\" +\n        \"import javax.persistence.*;\"\nbaseEntity = \"\"\n\ntypeMapping = [\n        (~/(?i)int/)                      : \"Long\",\n        (~/(?i)float|double|decimal|real/): \"Double\",\n        (~/(?i)datetime|timestamp/)       : \"LocalDateTime\",\n        (~/(?i)date/)                     : \"LocalDate\",\n        (~/(?i)time/)                     : \"LocalTime\",\n        (~/(?i)/)                         : \"String\"\n]\n\nFILES.chooseDirectoryAndSave(\"Choose directory\", \"Choose where to store generated files\") { dir -\u003e\n    SELECTION.filter { it instanceof DasTable }.each { generate(it, dir) }\n}\n\ndef generate(table, dir) {\n    def className = javaName(table.getName(), true)\n    def fields = calcFields(table)\n    new File(dir, className + \".java\").withPrintWriter { out -\u003e generate(out, className, fields, table) }\n}\n\ndef generate(out, className, fields, table) {\n    out.println \"package $packageName\"\n    out.println \"\"\n    out.println \"$importName\"\n    out.println \"\"\n    out.println \"\"\n\n\n    out.print \"/**\\n\" +\n                \" * \" + table.getComment() + \"\\n\" +\n                \" */\\n\"\n    out.println \"@Entity\"\n    out.println \"@Table(name = \\\"\" + table.getName() + \"\\\")\"\n    out.println \"@Builder\"\n    out.println \"@Getter\"\n    out.println \"@Setter\"\n    out.println \"@NoArgsConstructor\"\n    out.println \"@AllArgsConstructor\"\n    out.print \"public class $className \"\n    if (baseEntity != \"\") out.print \"extend $baseEntity \"\n    out.println \"{\"\n    out.println \"\"\n    fields.each() {\n        out.println \"\"\n        // 输出注释\n        if (isNotEmpty(it.comment)) \n            out.println \"    /** ${it.comment.toString()} */\"\n        if (it.isPrimary == true) out.println \"    @Id\"\n        if (it.isPrimary == true) out.println \"    @GeneratedValue(strategy = GenerationType.IDENTITY)\"\n        if (it.annos != \"\") out.println \"    ${it.annos}\"\n        out.println \"    private ${it.type} ${it.name};\"\n    }\n    out.println \"\"\n//    fields.each() {\n//        out.println \"\"\n//        out.println \"  public ${it.type} get${it.name.capitalize()}() {\"\n//        out.println \"    return ${it.name};\"\n//        out.println \"  }\"\n//        out.println \"\"\n//        out.println \"  public void set${it.name.capitalize()}(${it.type} ${it.name}) {\"\n//        out.println \"    this.${it.name} = ${it.name};\"\n//        out.println \"  }\"\n//        out.println \"\"\n//    }\n    out.println \"}\"\n}\n\ndef calcFields(table) {\n    DasUtil.getColumns(table).reduce([]) { fields, col -\u003e\n        def spec = Case.LOWER.apply(col.getDataType().getSpecification())\n        def typeStr = typeMapping.find { p, t -\u003e p.matcher(spec).find() }.value\n        def field = [\n                name   : javaName(col.getName(), false),\n                type   : typeStr,\n                comment: col.getComment(),\n                annos  : \"@Column(name = \\\"\" + col.getName() + \"\\\")\"]\n        if (\"id\" == Case.LOWER.apply(col.getName()))\n            field.isPrimary = true\n        fields += [field]\n    }\n}\n\ndef javaName(str, capitalize) {\n    def s = com.intellij.psi.codeStyle.NameUtil.splitNameIntoWords(str)\n            .collect { Case.LOWER.apply(it).capitalize() }\n            .join(\"\")\n            .replaceAll(/[^\\p{javaJavaIdentifierPart}[_]]/, \"_\")\n    capitalize || s.length() == 1 ? s : Case.LOWER.apply(s[0]) + s[1..-1]\n}\n\n\n//判断是否为空\nstatic def isNotEmpty(content) {\n    return content != null \u0026\u0026 content.toString().trim().length() \u003e 0\n}\n\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```"
								}
							]
						}
					]
				},
				{
					"ID": "20210925204904-tazm12b",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210925204904-tazm12b"
					},
					"Children": [
						{
							"ID": "20210925204904-7580zbv",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210925204904-7580zbv",
								"updated": "20210925204953"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "之后右键表"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Scripted Extensions"
								},
								{
									"Type": "NodeText",
									"Data": "—\u003e"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "code",
									"TextMarkTextContent": "Generate POJOs.groovy"
								},
								{
									"Type": "NodeText",
									"Data": "选择要保存的路径即可生成"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210925205007-lmsbd9k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210925205007-lmsbd9k",
				"updated": "20210925205011"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "方式2："
				}
			]
		},
		{
			"ID": "20210925205019-23ijd0a",
			"Type": "NodeList",
			"ListData": {},
			"Properties": {
				"id": "20210925205019-23ijd0a",
				"updated": "20210925205020"
			},
			"Children": [
				{
					"ID": "20210925205020-vmrg0cp",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210925205020-vmrg0cp"
					},
					"Children": [
						{
							"ID": "20210925205020-byfw3s6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210925205020-byfw3s6",
								"updated": "20210925205020"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "使用 IDEA 自带的 Datebase 连接数据库后"
								}
							]
						}
					]
				},
				{
					"ID": "20210925205025-proars0",
					"Type": "NodeListItem",
					"ListData": {
						"BulletChar": 42,
						"Marker": "Kg=="
					},
					"Properties": {
						"id": "20210925205025-proars0"
					},
					"Children": [
						{
							"ID": "20210925205025-ixzeb4a",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210925205025-ixzeb4a"
							},
							"Children": [
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "打开 Persistence 视图，点击 Generate Persistence Mapping"
								},
								{
									"Type": "NodeText",
									"Data": "，接着"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "点击选中数据源"
								},
								{
									"Type": "NodeText",
									"Data": "，然后，"
								},
								{
									"Type": "NodeTextMark",
									"TextMarkType": "strong",
									"TextMarkTextContent": "选择表和字段，并点击 OK"
								},
								{
									"Type": "NodeText",
									"Data": "。若没有 Persistence 视图，则需要在 Project Structure 中的 Module 添加 JPA（提供者为 Hibernate）"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210925202829-ahr1yjw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210925202829-ahr1yjw",
				"updated": "20210925202829"
			}
		},
		{
			"ID": "20210925201251-9nb3buy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210925201251-9nb3buy",
				"updated": "20210925202825"
			}
		},
		{
			"ID": "20210915230801-yljqf2r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915230801-yljqf2r",
				"updated": "20210915230801"
			}
		},
		{
			"ID": "20210915233842-ahrowj1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210915233842-ahrowj1",
				"updated": "20210915233842"
			}
		},
		{
			"ID": "20210707235333-iibyaxo",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210707235333-iibyaxo",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "联合主键"
				}
			]
		},
		{
			"ID": "20210707235333-rz6sgaz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-rz6sgaz",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "可以通过 javax.persistence.EmbeddedId 和 javax.persistence.IdClass 两个注解实现联合主键的效果。"
				}
			]
		},
		{
			"ID": "20210707235333-tlb3cy0",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-tlb3cy0",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过@Id 和 @IdClass 做到联合主键"
				}
			]
		},
		{
			"ID": "20210707235333-vw5imb6",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-vw5imb6",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "我们先看一下怎么通过 @IdClass 做到联合主键。"
				}
			]
		},
		{
			"ID": "20210707235333-osr2j6d",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-osr2j6d",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第一步：新建一个 UserInfoID 类里面是联合主键。"
				}
			]
		},
		{
			"ID": "20210707235333-dv1lxf8",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-dv1lxf8",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserInfoID implements Serializable {\n   private String name,telephone;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-neqjjkw",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-neqjjkw",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第二步：再新建一个 UserInfo 的实体，采用 @IdClass 引用联合主键类。"
				}
			]
		},
		{
			"ID": "20210707235333-8unbjuo",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-8unbjuo",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Entity\n@Data\n@Builder\n@IdClass(UserInfoID.class)\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserInfo {\n   private Integer ages;\n   @Id\n   private String name;\n   @Id\n   private String telephone;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-606q4fm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-606q4fm",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第三步：新增一个 UserInfoReposito 类来做 CRUD 操作。"
				}
			]
		},
		{
			"ID": "20210707235333-ldvglsw",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-ldvglsw",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public interface UserInfoRepository extends JpaRepository\u003cUserInfo,UserInfoID\u003e {\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-cz0vb4k",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-cz0vb4k",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第四步：写一个测试用例，测试一下。"
				}
			]
		},
		{
			"ID": "20210707235333-qcdsg5e",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-qcdsg5e",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@DataJpaTest\npublic class UserInfoRepositoryTest {\n   @Autowired\n   private UserInfoRepository userInfoRepository;\n   @Test\n   public void testIdClass() {\n   userInfoRepository.save(UserInfo.builder().ages(1).name(\"jack\").telephone(\"123456789\").build());\n      Optional\u003cUserInfo\u003e userInfo = userInfoRepository.findById(UserInfoID.builder().name(\"jack\").telephone(\"123456789\").build());\n      System.out.println(userInfo.get());\n   }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-nncpnmz",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-nncpnmz",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker"
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Hibernate: create table user_info (name varchar(255) not null, telephone varchar(255) not null, ages integer, primary key (name, telephone))\nHibernate: select userinfo0_.name as name1_3_0_, userinfo0_.telephone as telephon2_3_0_, userinfo0_.ages as ages3_3_0_ from user_info userinfo0_ where userinfo0_.name=? and userinfo0_.telephone=?\nUserInfo(ages=1, name=jack, telephone=123456789)\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-d29t6zj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-d29t6zj",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "通过上面的例子我们可以发现，我们的表的主键是 primary key (name, telephone)，而 Entity 里面不再是一个 @Id 字段了。那么我来介绍另外一个注解 @Embeddable，也能做到这一点。"
				}
			]
		},
		{
			"ID": "20210707235333-w160e5b",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707235333-w160e5b",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "@Embeddable 与 @EmbeddedId 注解使用"
				}
			]
		},
		{
			"ID": "20210707235333-fdyaboz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-fdyaboz",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第一步：在我们上面例子中的 UserInfoID 里面添加 @Embeddable 注解。"
				}
			]
		},
		{
			"ID": "20210707235333-w4im2p8",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-w4im2p8",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\n@Embeddable\npublic class UserInfoID implements Serializable {\n   private String name,telephone;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-q7o3las",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-q7o3las",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第二步：改一下我们刚才的 User 对象，删除 @IdClass，添加 @EmbeddedId 注解，如下："
				}
			]
		},
		{
			"ID": "20210707235333-ujyi3m6",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-ujyi3m6",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Entity\n@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class UserInfo {\n   private Integer ages;\n   @EmbeddedId\n   private UserInfoID userInfoID;\n   @Column(unique = true)\n   private String uniqueNumber;\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-dz87er5",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-dz87er5",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第三步：UserInfoRepository 不变，我们直接修改一下测试用例。"
				}
			]
		},
		{
			"ID": "20210707235333-qs7fg2w",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-qs7fg2w",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Test\npublic void testIdClass() {\n  userInfoRepository.save(UserInfo.builder().ages(1).userInfoID(UserInfoID.builder().name(\"jack\").telephone(\"123456789\").build()).build());\n   Optional\u003cUserInfo\u003e userInfo = userInfoRepository.findById(UserInfoID.builder().name(\"jack\").telephone(\"123456789\").build());\n   System.out.println(userInfo.get());\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-yb0ahs1",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-yb0ahs1",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "运行完之后，你可以得到相同的结果。那么 @IdClass 和 @EmbeddedId 的区别是什么？有以下两个方面："
				}
			]
		},
		{
			"ID": "20210707235333-219ggqe",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1
			},
			"Properties": {
				"id": "20210707235333-219ggqe",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"ID": "20210707235333-3zb5ys8",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "MS4=",
						"Num": 1
					},
					"Properties": {
						"id": "20210707235333-3zb5ys8"
					},
					"Children": [
						{
							"ID": "20210707235333-j1qq11s",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-j1qq11s"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "如上面测试用例，在使用的时候，Embedded 用的是对象，而 IdClass 用的是具体的某一个字段；"
								}
							]
						}
					]
				},
				{
					"ID": "20210707235333-4eqd2ie",
					"Type": "NodeListItem",
					"ListData": {
						"Typ": 1,
						"Delimiter": 46,
						"Marker": "Mi4=",
						"Num": 2
					},
					"Properties": {
						"id": "20210707235333-4eqd2ie"
					},
					"Children": [
						{
							"ID": "20210707235333-hp5uv4c",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-hp5uv4c"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "二者的 JPQL 也会不一样："
								}
							]
						},
						{
							"ID": "20210707235333-4tz5qpg",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-4tz5qpg"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "用 @IdClass JPQL 的写法：SELECT u.name FROM UserInfo u"
								}
							]
						},
						{
							"ID": "20210707235333-ac283o7",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707235333-ac283o7"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "用 @EmbeddedId 的 JPQL 的写法：select u.userInfoId.name FROM UserInfo u"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707235333-kwlqksc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-kwlqksc",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "联合主键还有需要注意的就是，它与唯一性索引约束的区别是写法不同，如上面所讲，唯一性索引的写法如下："
				}
			]
		},
		{
			"ID": "20210707235333-36jrrt6",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"Properties": {
				"id": "20210707235333-36jrrt6",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```"
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Column(unique = true)\nprivate String uniqueNumber;\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```"
				}
			]
		},
		{
			"ID": "20210707235333-ny6j2uk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-ny6j2uk",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "到这里，联合主键我们讲完了，那么在遇到联合主键的时候，利用 @IdClass、@EmbeddedId，你就可以应对联合主键了。"
				}
			]
		},
		{
			"ID": "20210707235333-c9ll60m",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707235333-c9ll60m",
				"updated": "20210707235333"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "此外，Java 是面向对象的，肯定会用到多态的使用场景，那么场景都有哪些？公共父类又该如何写？我们来学习一下。"
				}
			]
		}
	]
}