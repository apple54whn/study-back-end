{
	"ID": "20210707214420-kftgld0",
	"Type": "NodeDocument",
	"Properties": {
		"id": "20210707214420-kftgld0",
		"title": "501.Lambda",
		"type": "doc"
	},
	"Children": [
		{
			"ID": "20210707214420-zcaji8r",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-zcaji8r"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿什么东西做什么事情”。相对而言，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "面向对象"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "过分强调“必须"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "通过对象的形式来做事情"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "”，而"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "函数式思想"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "则尽量忽略面向对象的复杂语法——"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "强调做什么及结果，而不是以什么形式做"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210707214420-mdowxhd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-mdowxhd"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "面向对象的思想：做一件事情，找一个能解决这个事情的对象，调用对象的方法,完成事情."
				}
			]
		},
		{
			"ID": "20210707214420-lqq6j44",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-lqq6j44"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "函数式编程思想：只要能获取到结果，谁去做的，怎么做的都不重要，重视的是结果，不重视过程"
				}
			]
		},
		{
			"ID": "20210707214420-w8tj593",
			"Type": "NodeList",
			"ListData": {
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210707214420-w8tj593"
			},
			"Children": [
				{
					"ID": "20210707214420-v3z59mv",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-v3z59mv"
					},
					"Children": [
						{
							"ID": "20210707214420-wdurnn6",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-wdurnn6"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "冗余的 Runnable 代码分析"
								}
							]
						},
						{
							"ID": "20210707214420-fkdpf8q",
							"Type": "NodeList",
							"ListData": {
								"Tight": true,
								"BulletChar": 45,
								"Padding": 2,
								"Marker": "LQ==",
								"Num": -1
							},
							"Properties": {
								"id": "20210707214420-fkdpf8q"
							},
							"Children": [
								{
									"ID": "20210707214420-pxepczj",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-pxepczj"
									},
									"Children": [
										{
											"ID": "20210707214420-gt4ian0",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-gt4ian0"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "Thread 类需要 Runnable 接口作为参数，其中的抽象 run 方法是用来指定线程任务内容的核心；"
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-9tretwu",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-9tretwu"
									},
									"Children": [
										{
											"ID": "20210707214420-sxy6bjs",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-sxy6bjs"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "为了指定 run 的方法体，不得不需要 Runnable 接口的实现类；"
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-nab6ylo",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-nab6ylo"
									},
									"Children": [
										{
											"ID": "20210707214420-wo0jo7f",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-wo0jo7f"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "为了省去定义一个 RunnableImpl 实现类的麻烦，不得不使用匿名内部类；"
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-25st4xd",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-25st4xd"
									},
									"Children": [
										{
											"ID": "20210707214420-wwx7o2v",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-wwx7o2v"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "必须覆盖重写抽象 run 方法，所以方法名称、方法参数、方法返回值不得不再写一遍，且不能写错；"
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-g6dou87",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-g6dou87"
									},
									"Children": [
										{
											"ID": "20210707214420-65u3cla",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-65u3cla"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "而实际上，似乎只"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "有方法体才是关键所在"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "。"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-dv0mlhw",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-dv0mlhw"
					},
					"Children": [
						{
							"ID": "20210707214420-jedrloj",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-jedrloj"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "匿名内部类的好处与弊端"
								}
							]
						},
						{
							"ID": "20210707214420-3tbou8f",
							"Type": "NodeList",
							"ListData": {
								"Tight": true,
								"BulletChar": 45,
								"Padding": 2,
								"Marker": "LQ==",
								"Num": -1
							},
							"Properties": {
								"id": "20210707214420-3tbou8f"
							},
							"Children": [
								{
									"ID": "20210707214420-n0to1py",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-n0to1py"
									},
									"Children": [
										{
											"ID": "20210707214420-py3daja",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-py3daja"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "一方面，匿名内部类可以帮我们省去实现类的定义；"
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-xfnne1c",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-xfnne1c"
									},
									"Children": [
										{
											"ID": "20210707214420-tk6l6cs",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-tk6l6cs"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "另一方面，匿名内部类的语法——确实太复杂了！"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-q6pxw8s",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-q6pxw8s"
					},
					"Children": [
						{
							"ID": "20210707214420-2s05d9p",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-2s05d9p"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "编程思想转换"
								}
							]
						},
						{
							"ID": "20210707214420-9u1zmse",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-9u1zmse"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "做什么"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，而不是怎么做，只要能够更好地达到目的，过程与形式其实并不重要。2014 年 3 月 Oracle 所发布的 Java 8 中，加入了 Lambda 表达式的重量级新特性，为我们打开了新世界的大门。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-06t5eyy",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210707214420-06t5eyy"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "函数式接口"
				}
			]
		},
		{
			"ID": "20210707214420-zp10nai",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-zp10nai"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "函数式接口在 Java 中是指："
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "有且仅有一个抽象方法的接口"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。可以适用于 Lambda 使用的接口，只有确保接口为函数式接口，Java 中的 Lambda 才能顺利地进行"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "推导"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210707214420-l6bxr80",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20210707214420-l6bxr80"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e "
				},
				{
					"ID": "20210707214420-vnzp5qr",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20210707214420-vnzp5qr"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "备注：“语法糖”是指使用更加方便，但是原理不变的代码语法。例如在遍历集合时使用的 for-each 语法，其实底层的实现原理仍然是迭代器，这便是“语法糖”。从应用层面来讲，Java 中的 Lambda 可以被当做是匿名内部类的“语法糖”，但是二者在原理上是不同的。"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-89azka0",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-89azka0"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "格式"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-5h0dtsm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-5h0dtsm"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "修饰符 interface 接口名称 {\n    /*public abstract*/ 返回值类型 方法名称(可选参数信息);\n    // 其他非抽象方法内容，默认方法，静态方法，私有方法\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-ys6m6w3",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-ys6m6w3"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "@FunctionalInterface"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "注解"
				}
			]
		},
		{
			"ID": "20210707214420-zjqg1aj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-zjqg1aj"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Java 8 中专门为函数式接口引入的注解，可用于一个接口的定义上。一旦使用该注解来定义接口，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "编译器将会强制检查"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "该接口是否确实有且仅有一个抽象方法，否则将会报错。不使用该注解也可以定义函数式接口。"
				}
			]
		},
		{
			"ID": "20210707214420-d7ldjyt",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210707214420-d7ldjyt"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "函数式编程"
				}
			]
		},
		{
			"ID": "20210707214420-hv7sgv3",
			"Type": "NodeList",
			"ListData": {
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210707214420-hv7sgv3"
			},
			"Children": [
				{
					"ID": "20210707214420-7we4dft",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-7we4dft"
					},
					"Children": [
						{
							"ID": "20210707214420-q1zglah",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-q1zglah"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Lambda 表达式的标准格式为"
								}
							]
						},
						{
							"ID": "20210707214420-f6t6ufs",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-f6t6ufs"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "(参数类型 参数名称) ‐\u003e { 代码语句 }\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						},
						{
							"ID": "20210707214420-rxz27ng",
							"Type": "NodeList",
							"ListData": {
								"Tight": true,
								"BulletChar": 45,
								"Padding": 2,
								"Marker": "LQ==",
								"Num": -1
							},
							"Properties": {
								"id": "20210707214420-rxz27ng"
							},
							"Children": [
								{
									"ID": "20210707214420-mumiy3y",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-mumiy3y"
									},
									"Children": [
										{
											"ID": "20210707214420-1ocyupw",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-1ocyupw"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "小括号内的语法与传统方法"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "参数列表一致"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "：无参数则留空；多个参数则用逗号分隔。"
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-609d7db",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-609d7db"
									},
									"Children": [
										{
											"ID": "20210707214420-41tkndz",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-41tkndz"
											},
											"Children": [
												{
													"Type": "NodeCodeSpan",
													"CodeMarkerLen": 1,
													"Children": [
														{
															"Type": "NodeCodeSpanOpenMarker",
															"Data": "`"
														},
														{
															"Type": "NodeCodeSpanContent",
															"Data": "-\u003e"
														},
														{
															"Type": "NodeCodeSpanCloseMarker",
															"Data": "`"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": " 是新引入的语法格式，代表"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "指向动作"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "。"
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-mghlhi1",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-mghlhi1"
									},
									"Children": [
										{
											"ID": "20210707214420-hvdoh6v",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-hvdoh6v"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "大括号内的语法与传统"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "方法体"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "要求基本一致。"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-0fqiqtt",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-0fqiqtt"
					},
					"Children": [
						{
							"ID": "20210707214420-t3oyy7o",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-t3oyy7o"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "无参数返回值"
								}
							]
						},
						{
							"ID": "20210707214420-0ordexk",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-0ordexk"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "new Thread( () ‐\u003e  System.out.println(\"多线程任务执行！\")).start());\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-rna5s9d",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-rna5s9d"
					},
					"Children": [
						{
							"ID": "20210707214420-3dvq3ta",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-3dvq3ta"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "有参数和返回值"
								}
							]
						},
						{
							"ID": "20210707214420-qk7cwyh",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-qk7cwyh"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "Arrays.sort(students,(s1, s2)-\u003e{ //参数类型可以从students推导出，so可以省略\n    return s1.getAge()-s2.getAge();\n});\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						},
						{
							"ID": "20210707214420-zt2dhhy",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-zt2dhhy"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "Collections.sort(students, (o1, o2) -\u003e o1.getAge()-o2.getAge()); //{}内只有一行表达式，可以省略{}和return\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						},
						{
							"ID": "20210707214420-t3h4pn2",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-t3h4pn2"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "Arrays.sort(students, Comparator.comparingInt(Student::getAge)); //更简洁的写法,但{}中语句多时不能简写\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-2wko02g",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-2wko02g"
					},
					"Children": [
						{
							"ID": "20210707214420-iquxw2y",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-iquxw2y"
							},
							"Children": [
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "可推导可省略"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "：Lambda 强调的是“做什么”而不是“怎么做”，凡可以根据上下文推导得知的信息，都可以省略。"
								}
							]
						},
						{
							"ID": "20210707214420-6rfbl4j",
							"Type": "NodeList",
							"ListData": {
								"Tight": true,
								"BulletChar": 45,
								"Padding": 2,
								"Marker": "LQ==",
								"Num": -1
							},
							"Properties": {
								"id": "20210707214420-6rfbl4j"
							},
							"Children": [
								{
									"ID": "20210707214420-9f541mi",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-9f541mi"
									},
									"Children": [
										{
											"ID": "20210707214420-ekay26x",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-ekay26x"
											},
											"Children": [
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "小括号内参数的类型"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "可以省略"
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-fv7mzmn",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-fv7mzmn"
									},
									"Children": [
										{
											"ID": "20210707214420-mksbqt5",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-mksbqt5"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "如果"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "小括号内有且仅有一个参"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "，则"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "小括号可以省略"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-vt5px16",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-vt5px16"
									},
									"Children": [
										{
											"ID": "20210707214420-n56fqk2",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-n56fqk2"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "如果"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "大括号内有且仅有一个语句"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "，则无论是否有返回值，都可以省略大括号、return 关键字及语句分号。"
												}
											]
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-ladxogn",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-ladxogn"
					},
					"Children": [
						{
							"ID": "20210707214420-b8gnxkq",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-b8gnxkq"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Lambda 的语法非常简洁，完全没有面向对象复杂的束缚。但是使用时有几个问题需要特别注意："
								}
							]
						},
						{
							"ID": "20210707214420-t2sre06",
							"Type": "NodeList",
							"ListData": {
								"BulletChar": 45,
								"Padding": 2,
								"Marker": "LQ==",
								"Num": -1
							},
							"Properties": {
								"id": "20210707214420-t2sre06"
							},
							"Children": [
								{
									"ID": "20210707214420-pnwzx8i",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-pnwzx8i"
									},
									"Children": [
										{
											"ID": "20210707214420-8hvqsvz",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-8hvqsvz"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "使用 Lambda 必须具有"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "函数式接口"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "，其本质就是一个"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "函数式接口的实例"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												}
											]
										},
										{
											"ID": "20210707214420-jf88gn0",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-jf88gn0"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "无论是 JDK 内置的 Runnable 、 Comparator 接口还是自定义的接口，只有当接口中的抽象方法存在且唯一时，才可以使用 Lambda。"
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-bw0pz6c",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-bw0pz6c"
									},
									"Children": [
										{
											"ID": "20210707214420-sqozd8w",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-sqozd8w"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "使用 Lambda 必须"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "具有上下文类型推断"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												}
											]
										},
										{
											"ID": "20210707214420-3hkw57u",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-3hkw57u"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "方法的参数或局部变量类型必须为"
												},
												{
													"Type": "NodeStrong",
													"Children": [
														{
															"Type": "NodeStrongA6kOpenMarker",
															"Data": "**"
														},
														{
															"Type": "NodeText",
															"Data": "Lambda 对应的接口类型"
														},
														{
															"Type": "NodeStrongA6kCloseMarker",
															"Data": "**"
														}
													]
												},
												{
													"Type": "NodeText",
													"Data": "，才能使用 Lambda 作为该接口的实例。"
												}
											]
										}
									]
								},
								{
									"ID": "20210707214420-hz4f2cm",
									"Type": "NodeListItem",
									"Data": "-",
									"ListData": {
										"Tight": true,
										"BulletChar": 45,
										"Padding": 2,
										"Marker": "LQ==",
										"Num": -1
									},
									"Properties": {
										"id": "20210707214420-hz4f2cm"
									},
									"Children": [
										{
											"ID": "20210707214420-ut0zyjx",
											"Type": "NodeParagraph",
											"Properties": {
												"id": "20210707214420-ut0zyjx"
											},
											"Children": [
												{
													"Type": "NodeText",
													"Data": "若 Lambda 表达式抛出一个受检异常（即非运行时异常），那么该异常需要在目标接口的抽象方法上进行声明"
												}
											]
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-6jz2391",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210707214420-6jz2391"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "Lambda 的延迟执行"
				}
			]
		},
		{
			"ID": "20210707214420-wu8qd60",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-wu8qd60"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有些场景的代码执行后，结果不一定会被使用，从而造成性能浪费。而 Lambda 表达式是延迟执行的，这正好可以 作为解决方案，提升性能。"
				}
			]
		},
		{
			"ID": "20210707214420-3py4iaf",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-3py4iaf"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "性能浪费的日志案例"
				}
			]
		},
		{
			"ID": "20210707214420-n3kbdzb",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-n3kbdzb"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public static void main(String[] args) throws FileNotFoundException {\n    String a = \"hello\";\n    String b = \"world\";\n    log(1,a+b);\n}\npublic static void log(int level,String msg) {\n    if (level==1) {\n        System.out.println(msg);\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-6jxzl9r",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20210707214420-6jxzl9r"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e "
				},
				{
					"ID": "20210707214420-11bki61",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20210707214420-11bki61"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "无论级别是否满足要求，作为"
						},
						{
							"Type": "NodeCodeSpan",
							"CodeMarkerLen": 1,
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker",
									"Data": "`"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "log"
								},
								{
									"Type": "NodeCodeSpanCloseMarker",
									"Data": "`"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": " 方法的第二个参数，三个字符串一定会首先被拼接并传入方法内，然后才会进行级别判断。如果级别不符合要求，那么字符串的拼接操作就白做了，存在"
						},
						{
							"Type": "NodeStrong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "性能浪费"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "。"
						}
					]
				},
				{
					"ID": "20210707214420-q4889lj",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20210707214420-q4889lj"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "备注："
						},
						{
							"Type": "NodeStrong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "SLF4J"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "是应用非常广泛的日志框架，它在记录日志时为了解决这种性能浪费的问题，并不推荐首先进行字符串的拼接，而是"
						},
						{
							"Type": "NodeStrong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "将字符串的若干部分作为可变参数传入方法中"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "，仅在日志级别"
						},
						{
							"Type": "NodeStrong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "满足要求"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "的情况下"
						},
						{
							"Type": "NodeStrong",
							"Children": [
								{
									"Type": "NodeStrongA6kOpenMarker",
									"Data": "**"
								},
								{
									"Type": "NodeText",
									"Data": "才会进行字符串拼接"
								},
								{
									"Type": "NodeStrongA6kCloseMarker",
									"Data": "**"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "。例如： LOGGER.debug(\"变量{}的取值为{}。\", \"os\", \"macOS\") ，其中的大括号 {} 为占位符。如果满足日志级别要求，则会将“os”和“macOS”两个字符串依次拼接到大括号的位置；否则不会进行字 符串拼接。这也是一种可行解决方案，但 Lambda 可以做到更好"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-ot5j4z2",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-ot5j4z2"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "体验 Lambda 的更优写法"
				}
			]
		},
		{
			"ID": "20210707214420-25f8hn4",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-25f8hn4"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "函数式接口"
				}
			]
		},
		{
			"ID": "20210707214420-138vqx0",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-138vqx0"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@FunctionalInterface\npublic interface MessageBuilder {\n    String buildMessage();\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-vg7x573",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-vg7x573"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "然后对 "
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "log"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 方法进行改造"
				}
			]
		},
		{
			"ID": "20210707214420-gldo32z",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-gldo32z"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public static void main(String[] args) throws FileNotFoundException {\n    String a = \"hello\";\n    String b = \"world\";\n    log(1, () -\u003e a + b );\n}\npublic static void log(int level,MessageBuilder mb) {\n    if (level==1) {\n        System.out.println(mb.buildMessage());\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-gmmrbyk",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20210707214420-gmmrbyk"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e "
				},
				{
					"ID": "20210707214420-2j11m19",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20210707214420-2j11m19"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "只有当级别满足要求的时候，才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。"
						}
					]
				},
				{
					"ID": "20210707214420-qm4lf44",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20210707214420-qm4lf44"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "证明：只需在 lambda 大括号中打印一个语句，并让"
						},
						{
							"Type": "NodeCodeSpan",
							"CodeMarkerLen": 1,
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker",
									"Data": "`"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "log"
								},
								{
									"Type": "NodeCodeSpanCloseMarker",
									"Data": "`"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": "方法传递的参数改为 2，发现打印语句不执行"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-p7y2775",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210707214420-p7y2775"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "常用的函数式接口"
				}
			]
		},
		{
			"ID": "20210707214420-cifxjgq",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-cifxjgq"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "JDK 提供了大量常用的函数式接口以丰富 Lambda 的典型使用场景，它们主要在"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeCodeSpan",
							"CodeMarkerLen": 1,
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker",
									"Data": "`"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "java.util.function"
								},
								{
									"Type": "NodeCodeSpanCloseMarker",
									"Data": "`"
								}
							]
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "中提供。"
				}
			]
		},
		{
			"ID": "20210707214420-cn753qf",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-cn753qf"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "java.lang.Runnable"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "、"
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "java.util.Comparator"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "不再上述包中，但也是函数式接口"
				}
			]
		},
		{
			"ID": "20210707214420-0n8fn2d",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20210707214420-0n8fn2d"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e "
				},
				{
					"ID": "20210707214420-bx73tro",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20210707214420-bx73tro"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "如下函数式接口强调的是状态的改变！不在乎具体实现细节！具体实现交给 Lambda 来完成！"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-9s5wwl2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-9s5wwl2"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "Java 内置四大核心函数式接口"
				}
			]
		},
		{
			"ID": "20210707214420-41huztm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-41huztm"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!"
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "["
						},
						{
							"Type": "NodeLinkText",
							"Data": "image-20191105234610241"
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]"
						},
						{
							"Type": "NodeOpenParen",
							"Data": "("
						},
						{
							"Type": "NodeLinkDest",
							"Data": "../assets/image-20191105234610241.png"
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-d7zmryk",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-d7zmryk"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "其他接口"
				}
			]
		},
		{
			"ID": "20210707214420-6o2u04b",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-6o2u04b"
			},
			"Children": [
				{
					"Type": "NodeImage",
					"Children": [
						{
							"Type": "NodeBang",
							"Data": "!"
						},
						{
							"Type": "NodeOpenBracket",
							"Data": "["
						},
						{
							"Type": "NodeLinkText",
							"Data": "image-20191105234644979"
						},
						{
							"Type": "NodeCloseBracket",
							"Data": "]"
						},
						{
							"Type": "NodeOpenParen",
							"Data": "("
						},
						{
							"Type": "NodeLinkDest",
							"Data": "../assets/image-20191105234644979.png"
						},
						{
							"Type": "NodeCloseParen",
							"Data": ")"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-fkwh3h3",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-fkwh3h3"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "Supplier—生产型接口"
				}
			]
		},
		{
			"ID": "20210707214420-1xnveqc",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-1xnveqc"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "java.util.function.Supplier\u003cT\u003e"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "用来"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "获取一个泛型参数指定类型的对象数据"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。由于这是一个函数式接口，这也就意味着对应的 Lambda 表达式"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "需要“对外提供”一个符合泛型类型"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的对象数据。这个接口也称为"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "生产型接口"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210707214420-yjizfx7",
			"Type": "NodeList",
			"ListData": {
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210707214420-yjizfx7"
			},
			"Children": [
				{
					"ID": "20210707214420-1c0basl",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-1c0basl"
					},
					"Children": [
						{
							"ID": "20210707214420-ixmhnsf",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-ixmhnsf"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "抽象方法 "
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "T get()"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								}
							]
						},
						{
							"ID": "20210707214420-6gkih0m",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-6gkih0m"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "//求数组元素最大值\npublic static void main(String[] args) {\n  int[] arr = {1, 22, 55, 333, 66};\n  int m = getMax(arr,() -\u003e {\n    int max = arr[0];\n    for (int i = 1; i \u003c arr.length; i++) {\n      if (arr[i] \u003e max)\n        max = arr[i];\n    }\n    return max;\n  });\n  System.out.println(m);\n}\n\npublic static int getMax(int[] arr,Supplier\u003cInteger\u003e supplier) {\n  return supplier.get();\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-tsljfw5",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-tsljfw5"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "Consumer—消费型接口"
				}
			]
		},
		{
			"ID": "20210707214420-wms7wtd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-wms7wtd"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "java.util.function.Consumer\u003cT\u003e"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "接口则正好与"
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "Supplier"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "接口相反，它不是生产一个数据。"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "消费型接口"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。"
				}
			]
		},
		{
			"ID": "20210707214420-182nd8q",
			"Type": "NodeList",
			"ListData": {
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210707214420-182nd8q"
			},
			"Children": [
				{
					"ID": "20210707214420-q63ns6f",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-q63ns6f"
					},
					"Children": [
						{
							"ID": "20210707214420-uzk7ekw",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-uzk7ekw"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "抽象方法"
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "void accept(T t)"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								}
							]
						},
						{
							"ID": "20210707214420-7h9mmps",
							"Type": "NodeBlockquote",
							"Properties": {
								"id": "20210707214420-7h9mmps"
							},
							"Children": [
								{
									"Type": "NodeBlockquoteMarker",
									"Data": "\u003e "
								},
								{
									"ID": "20210707214420-coo5lda",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20210707214420-coo5lda"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "意为"
										},
										{
											"Type": "NodeStrong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "消费一个指定泛型的数据"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeText",
											"Data": "。"
										}
									]
								}
							]
						},
						{
							"ID": "20210707214420-dnzewt2",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-dnzewt2"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public static void main(String[] args) {\n    String msg = \"牛逼\";\n    consumeString(msg,s ‐\u003e {\n        //怎么处里消费随意\n    }\n}\n\npublic static void consumeString(String msg, Consumer\u003cString\u003e consumer) {\n    consumer.accept(msg);\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-x909ht6",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-x909ht6"
					},
					"Children": [
						{
							"ID": "20210707214420-sgdev10",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-sgdev10"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "默认方法"
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "default Consumer\u003cT\u003e andThen(Consumer\u003cT\u003e c)"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								}
							]
						},
						{
							"ID": "20210707214420-i47j9yr",
							"Type": "NodeBlockquote",
							"Properties": {
								"id": "20210707214420-i47j9yr"
							},
							"Children": [
								{
									"Type": "NodeBlockquoteMarker",
									"Data": "\u003e "
								},
								{
									"ID": "20210707214420-bpqusmb",
									"Type": "NodeParagraph",
									"Properties": {
										"id": "20210707214420-bpqusmb"
									},
									"Children": [
										{
											"Type": "NodeText",
											"Data": "如果一个方法的参数和返回值全都是 Consumer 类型，那么就可以实现效果："
										},
										{
											"Type": "NodeStrong",
											"Children": [
												{
													"Type": "NodeStrongA6kOpenMarker",
													"Data": "**"
												},
												{
													"Type": "NodeText",
													"Data": "消费数据的时候，首先做一个操作， 然后再做一个操作，实现组合，哪个写前面则先消费"
												},
												{
													"Type": "NodeStrongA6kCloseMarker",
													"Data": "**"
												}
											]
										},
										{
											"Type": "NodeText",
											"Data": "。返回值是本身，可以用链式编程，三个、四个操作都行。这个方法就是 Consumer 接口中的 default 方法 andThen 。"
										}
									]
								}
							]
						},
						{
							"ID": "20210707214420-p8v2cck",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-p8v2cck"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public static void main(String[] args) {\n    /**\n     * 下面的字符串数组当中存有多条信息，请按照格式“ 姓名：XX；性别：XX。 ”的格式将信息打印出来。\n     * 要求将打印姓名的动作作为第一个Consumer接口的Lambda实例，将打印性别的动作作为第二个Consumer接口的Lambda实例，\n     */\n    String[] arr = {\"迪丽热巴,女\", \"古力娜扎,女\", \"马尔扎哈,男\"};\n    consumerString(arr,\n                   s -\u003e System.out.print(\"姓名：\" + s.split(\",\")[0] + \"；\"),\n                   s -\u003e System.out.println(\"性别：\" + s.split(\",\")[1] + \"。\")\n    );\n\n}\n\npublic static void consumerString(String[] msg, Consumer\u003cString\u003e consumer1, Consumer\u003cString\u003e consumer2) {\n    for (String s : msg) {\n        consumer1.andThen(consumer2).accept(s);\n    }\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-gbm3psq",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-gbm3psq"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "Predicate—判断"
				}
			]
		},
		{
			"ID": "20210707214420-74k2ege",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-74k2ege"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "有时候我们需要"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "对某种类型的数据进行判断"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，从而得到一个 boolean 值结果。这时可以使用 "
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "java.util.function.Predicate\u003cT\u003e"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "接口。"
				}
			]
		},
		{
			"ID": "20210707214420-xb15kye",
			"Type": "NodeList",
			"ListData": {
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210707214420-xb15kye"
			},
			"Children": [
				{
					"ID": "20210707214420-pbb3hc6",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-pbb3hc6"
					},
					"Children": [
						{
							"ID": "20210707214420-uvf84bl",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-uvf84bl"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "抽象方法： "
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "boolean test(T t)"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								}
							]
						},
						{
							"ID": "20210707214420-srqy39n",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-srqy39n"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "//判断字符串长度是否大于3\npublic static void main(String[] args) {\n    String msg = \"hello\";\n    boolean b = panduan(msg, s -\u003e s.length() \u003e 3);\n    System.out.println(b);\n\n}\npublic static boolean panduan(String s, Predicate\u003cString\u003e predicate){\n    return predicate.test(s);\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-g6bw5kj",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-g6bw5kj"
					},
					"Children": [
						{
							"ID": "20210707214420-dhn1vxu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-dhn1vxu"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "默认方法："
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "Predicate\u003cT\u003e and(Predicate\u003c? super T\u003e other)"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，与"
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-hbimaxd",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-hbimaxd"
					},
					"Children": [
						{
							"ID": "20210707214420-838v5pm",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-838v5pm"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "默认方法："
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "Predicate\u003cT\u003e or(Predicate\u003c? super T\u003e other)"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，或"
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-xa3l6n8",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-xa3l6n8"
					},
					"Children": [
						{
							"ID": "20210707214420-5nr2qgn",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-5nr2qgn"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "默认方法："
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "Predicate\u003cT\u003e negate()"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": " ，非"
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-2a9g9gf",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-2a9g9gf"
					},
					"Children": [
						{
							"ID": "20210707214420-3h9uvto",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-3h9uvto"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "静态方法："
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "static \u003cT\u003e Predicate\u003cT\u003e isEqual(Object targetRef)"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，相等，根据"
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "Objects.equals(O,O)"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								}
							]
						},
						{
							"ID": "20210707214420-408m66d",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-408m66d"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "System.out.println(Predicate.isEqual(\"test\").test(\"test\"));//true，返回Predicate实例，之后也可以用其他方法\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						},
						{
							"ID": "20210707214420-cdqqlbx",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-cdqqlbx"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public static void main(String[] args) {\n    String msg = \"hello\";\n    boolean b = panduan(msg,s -\u003e s.length() \u003e 3,s -\u003e s.contains(\"w\"));\n    System.out.println(b);\n\n}\npublic static boolean panduan(String s, Predicate\u003cString\u003e p1,Predicate\u003cString\u003e p2){\n    return p1.and(p2).test(s); //and\n    //return p1.or(p2).test(s); //or\n    //return p1.negate().and(p2).test(s); //negate\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						},
						{
							"ID": "20210707214420-7h6q6xl",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-7h6q6xl"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public static void main(String[] args) {\n    /**\n         * 数组当中有多条“姓名+性别”的信息如下，请通过 Predicate 接口的拼装将符合要求的字符串筛选到集合 ArrayList 中\n         * 需要同时满足两个条件：1. 必须为女生； 2. 姓名为4个字。\n         */\n    String[] array = {\"迪丽热巴,女\", \"古力娜扎,女\", \"马尔扎哈,男\", \"赵丽颖,女\"};\n    ArrayList\u003cString\u003e list = toList(array,\n                                    s -\u003e s.split(\",\")[0].length() == 4,\n                                    s -\u003e \"女\".equals(s.split(\",\")[1])\n    );\n    System.out.println(list);\n}\n\npublic static ArrayList\u003cString\u003e toList(String[] arr, Predicate\u003cString\u003e p1, Predicate\u003cString\u003e p2) {\n    ArrayList\u003cString\u003e list = new ArrayList\u003c\u003e();\n    for (String s : arr) {\n        if (p1.and(p2).test(s))\n            list.add(s);\n    }\n    return list;\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-uptj6s5",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-uptj6s5"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "Function"
				}
			]
		},
		{
			"ID": "20210707214420-ax9qktj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-ax9qktj"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "java.util.function.Function\u003cT,R\u003e"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 接口用来"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "根据一个类型的数据得到另一个类型的数据"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，前者称为前置条件， 后者称为后置条件。"
				}
			]
		},
		{
			"ID": "20210707214420-xec2gi1",
			"Type": "NodeList",
			"ListData": {
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210707214420-xec2gi1"
			},
			"Children": [
				{
					"ID": "20210707214420-7x7lwlz",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-7x7lwlz"
					},
					"Children": [
						{
							"ID": "20210707214420-ulcc9ij",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-ulcc9ij"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "抽象方法： "
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "R apply(T t)"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "：根据类型 T 的参数获取类型 R 的结果。如"
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "String"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "转"
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "Integer"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-b7ekhcq",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-b7ekhcq"
					},
					"Children": [
						{
							"ID": "20210707214420-i33llof",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-i33llof"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "默认方法："
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "Function\u003cT,V\u003e andThen(Function\u003c? super R,? extends V\u003e after)"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，用来"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "组合操作"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								}
							]
						},
						{
							"ID": "20210707214420-gcigedk",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-gcigedk"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public static void main(String[] args) {\n    /**\n         * 第一个操作是将字符串解析成为int数字，\n         * 第二个操作是乘以10并转为字符串。两个操作通过 andThen 按照前后顺序组合到了一 起。\n         */\n    String msg = \"1234\";\n    String string = change(msg, s -\u003e Integer.valueOf(s), s -\u003e (s * 10)+\"\" /*或String.valueOf()*/);\n    System.out.println(string);\n}\n\npublic static String change(String msg, Function\u003cString, Integer\u003e f1, Function\u003cInteger, String\u003e f2) {\n    return f1.andThen(f2).apply(msg);\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						},
						{
							"ID": "20210707214420-1g6llg6",
							"Type": "NodeCodeBlock",
							"IsFencedCodeBlock": true,
							"CodeBlockFenceChar": 96,
							"CodeBlockFenceLen": 3,
							"CodeBlockOpenFence": "YGBg",
							"CodeBlockInfo": "amF2YQ==",
							"CodeBlockCloseFence": "YGBg",
							"Properties": {
								"id": "20210707214420-1g6llg6"
							},
							"Children": [
								{
									"Type": "NodeCodeBlockFenceOpenMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								},
								{
									"Type": "NodeCodeBlockFenceInfoMarker",
									"CodeBlockInfo": "amF2YQ=="
								},
								{
									"Type": "NodeCodeBlockCode",
									"Data": "public static void main(String[] args) {\n    String str = \"赵丽颖,20\";\n    //1. 将字符串截取数字年龄部分，得到字符串；\n    //2. 将上一步的字符串转换成为int类型的数字；\n    //3. 将上一步的int数字累加100，得到结果int数字\n    int change = change(str,\n                        s -\u003e s.split(\",\")[1],\n                        s -\u003e Integer.parseInt(s),\n                        i -\u003e i + 100\n    );\n    System.out.println(change);\n}\n\npublic static int change(String s, Function\u003cString, String\u003e f1,\n                         Function\u003cString, Integer\u003e f2, Function\u003cInteger, Integer\u003e f3) {\n    return f1.andThen(f2).andThen(f3).apply(s);\n}\n"
								},
								{
									"Type": "NodeCodeBlockFenceCloseMarker",
									"Data": "```",
									"CodeBlockFenceLen": 3
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-6k1jqbs",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210707214420-6k1jqbs"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "方法引用"
				}
			]
		},
		{
			"ID": "20210707214420-l8pa8xz",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20210707214420-l8pa8xz"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e "
				},
				{
					"ID": "20210707214420-4b9balm",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20210707214420-4b9balm"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "在使用 Lambda 表达式的时候，我们实际上传递进去的代码就是一种解决方案：拿什么参数做什么操作。那么考虑 一种情况：如果我们在 Lambda 中所指定的操作方案，已经有地方存在相同方案，那是否还有必要再写重复逻辑？"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-3mowul2",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-3mowul2"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "引用符::"
				}
			]
		},
		{
			"ID": "20210707214420-568hb2z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-568hb2z"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "双冒号"
						},
						{
							"Type": "NodeCodeSpan",
							"CodeMarkerLen": 1,
							"Children": [
								{
									"Type": "NodeCodeSpanOpenMarker",
									"Data": "`"
								},
								{
									"Type": "NodeCodeSpanContent",
									"Data": "::"
								},
								{
									"Type": "NodeCodeSpanCloseMarker",
									"Data": "`"
								}
							]
						},
						{
							"Type": "NodeText",
							"Data": " 为引用运算符"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，而它所在的"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "表达式被称为方法引用"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "。如果 Lambda 要表达的"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "函数方案（方法体）已经存在于某个方法的实现中（出入参一致仅代表对象::非静态方法和类名::静态方法）"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，那么则可以通过双冒号来引用该方法作为 Lambda 的替代者。"
				}
			]
		},
		{
			"ID": "20210707214420-kt8hdoz",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-kt8hdoz"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "语义分析"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-ocfcm4l",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-ocfcm4l"
			},
			"Children": [
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "System.out"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "对象中有一个重载的 "
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "println(String)"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 方法恰好就是我们所需要的。那么对于 "
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "printString"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 方法的函数式接口参数，对比下面两种写法，完全等效："
				}
			]
		},
		{
			"ID": "20210707214420-k27cp2n",
			"Type": "NodeList",
			"ListData": {
				"Tight": true,
				"BulletChar": 45,
				"Padding": 2,
				"Marker": "LQ==",
				"Num": -1
			},
			"Properties": {
				"id": "20210707214420-k27cp2n"
			},
			"Children": [
				{
					"ID": "20210707214420-c8s9pam",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-c8s9pam"
					},
					"Children": [
						{
							"ID": "20210707214420-pry17o8",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-pry17o8"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "Lambda 表达式写法： "
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "s -\u003e System.out.println(s);"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-mahpntf",
					"Type": "NodeListItem",
					"Data": "-",
					"ListData": {
						"Tight": true,
						"BulletChar": 45,
						"Padding": 2,
						"Marker": "LQ==",
						"Num": -1
					},
					"Properties": {
						"id": "20210707214420-mahpntf"
					},
					"Children": [
						{
							"ID": "20210707214420-xn9w0fe",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-xn9w0fe"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "方法引用写法： "
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "System.out::println"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-baxkqj7",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-baxkqj7"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第一种语义是指：拿到参数之后经 Lambda 之手，继而传递给 "
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "System.out.println"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 方法去处理。"
				}
			]
		},
		{
			"ID": "20210707214420-zr6qo1t",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-zr6qo1t"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "第二种等效写法的语义是指：直接让 "
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "System.out"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 中的 "
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "println"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 方法来取代 Lambda"
				}
			]
		},
		{
			"ID": "20210707214420-wwtrv0m",
			"Type": "NodeBlockquote",
			"Properties": {
				"id": "20210707214420-wwtrv0m"
			},
			"Children": [
				{
					"Type": "NodeBlockquoteMarker",
					"Data": "\u003e "
				},
				{
					"ID": "20210707214420-4zvquus",
					"Type": "NodeParagraph",
					"Properties": {
						"id": "20210707214420-4zvquus"
					},
					"Children": [
						{
							"Type": "NodeText",
							"Data": "注：Lambda 中传递的参数 一定是方法引用中的那个方法可以接收的类型，否则会抛出异常"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-48vsqxj",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-48vsqxj"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "推导与省略"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-lyu8o1z",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-lyu8o1z"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果使用 Lambda，那么根据“可推导就是可省略”的原则，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "无需指定参数类型"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "也无需指定的重载形式"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "——它们都将被自动推导。而如果使用方法引用，也是同样可以根据上下文进行推导。"
				}
			]
		},
		{
			"ID": "20210707214420-tj06jdy",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-tj06jdy"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "函数式接口是 Lambda 的基础，而方法引用是 Lambda 的孪生兄弟。"
				}
			]
		},
		{
			"ID": "20210707214420-45zuj31",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-45zuj31"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "对象::非静态方法"
				}
			]
		},
		{
			"ID": "20210707214420-stj6wy2",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-stj6wy2"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "与上例相同。对象已经存在，方法也存在，可以使用"
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "对象名::方法名"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "替代 lambda"
				}
			]
		},
		{
			"ID": "20210707214420-oas1nqg",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-oas1nqg"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//Consumer中的void accept(T t)\n//PrintStream中的void println(T t)\n@Test\npublic void test1() {\n  Consumer\u003cString\u003e con1 = str -\u003e System.out.println(str);\n  con1.accept(\"北京\");\n\n  System.out.println(\"*******************\");\n  PrintStream ps = System.out;\n  Consumer\u003cString\u003e con2 = ps::println;\n  con2.accept(\"beijing\");\n}\n\n//Supplier中的T get()\n//Employee中的String getName()\n@Test\npublic void test2() {\n  Employee emp = new Employee(1001,\"Tom\",23,5600);\n\n  Supplier\u003cString\u003e sup1 = () -\u003e emp.getName();\n  System.out.println(sup1.get());\n\n  System.out.println(\"*******************\");\n  Supplier\u003cString\u003e sup2 = emp::getName;\n  System.out.println(sup2.get());\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-shidi95",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-shidi95"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "类名::静态方法"
				}
			]
		},
		{
			"ID": "20210707214420-dy8tvgm",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-dy8tvgm"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "类已经存在，静态方法也存在，可以使用"
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "类名::静态方法"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "替代 lambda"
				}
			]
		},
		{
			"ID": "20210707214420-vt6wwdm",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-vt6wwdm"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public interface Calcable {\n    int calc(int num);\n}\n// -------------------------------\npublic static void main(String[] args) {\n    method(‐10, Math::abs);\n}\nprivate static void method(int num, Calcable lambda) {\n    System.out.println(lambda.calc(num));\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-wbxa91r",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-wbxa91r"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//Comparator中的int compare(T t1,T t2)\n//Integer中的int compare(T t1,T t2)\n@Test\npublic void test3() {\n  Comparator\u003cInteger\u003e com1 = (t1,t2) -\u003e Integer.compare(t1,t2);\n  System.out.println(com1.compare(12,21));\n\n  System.out.println(\"*******************\");\n\n  Comparator\u003cInteger\u003e com2 = Integer::compare;\n  System.out.println(com2.compare(12,3));\n\n}\n\n//Function中的R apply(T t)\n//Math中的Long round(Double d)\n@Test\npublic void test4() {\n  Function\u003cDouble,Long\u003e func = new Function\u003cDouble, Long\u003e() {\n    @Override\n    public Long apply(Double d) {\n      return Math.round(d);\n    }\n  };\n\n  System.out.println(\"*******************\");\n\n  Function\u003cDouble,Long\u003e func1 = d -\u003e Math.round(d);\n  System.out.println(func1.apply(12.3));\n\n  System.out.println(\"*******************\");\n\n  Function\u003cDouble,Long\u003e func2 = Math::round;\n  System.out.println(func2.apply(12.6));\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-6pcbu8k",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-6pcbu8k"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "类名::非静态方法"
				}
			]
		},
		{
			"ID": "20210707214420-76qfi72",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-76qfi72"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "当函数式接口方法的第一个参数是需要引用方法的调用者，并且第二个参数是需要引用方法的参数（或无参数）时，可以使用"
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "类名::非静态方法"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "替代 lambda"
				}
			]
		},
		{
			"ID": "20210707214420-y6j859l",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-y6j859l"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "通过 super 引用成员方法"
				}
			]
		},
		{
			"ID": "20210707214420-wcfctcd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-wcfctcd"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "如果存在继承关系，当 Lambda 中需要出现 super 调用时，也可以使用方法引用进行替代。"
				}
			]
		},
		{
			"ID": "20210707214420-8p2a3wo",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-8p2a3wo"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@FunctionalInterface\npublic interface Greetable {\n    void greet();\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-3grzw09",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-3grzw09"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Human {\n    public void sayHello() {\n        System.out.println(\"Hello!\");\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-h7e67or",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-h7e67or"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Man extends Human {\n    @Override\n    public void sayHello() {\n        System.out.println(\"大家好,我是Man!\");\n    }\n    //定义方法method,参数传递Greetable接口\n    public void method(Greetable g){\n        g.greet();\n    }\n    public void show(){ //在main中调用此方法时，会打印Hello！\n        //method(()‐\u003esuper.sayHello());\n        method(super::sayHello);\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-yzaw7aa",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-yzaw7aa"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "通过 this 引用成员方法"
				}
			]
		},
		{
			"ID": "20210707214420-ye5yokd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-ye5yokd"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "this 代表当前对象，如果需要引用的方法就是当前类中的成员方法，那么可以使用"
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "this::成员方法"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "的格式来使用方法引用"
				}
			]
		},
		{
			"ID": "20210707214420-b8x2bqt",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-b8x2bqt"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@FunctionalInterface\npublic interface Richable {\n    void buy();\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-vdct5d1",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-vdct5d1"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Husband {\n    private void buyHouse() {\n        System.out.println(\"买套房子\");\n    }\n    private void marry(Richable lambda) {\n        lambda.buy();\n    }\n    public void beHappy() { //main中调用此方法，会打印 买套房子\n        //marry(() ‐\u003e this.buyHouse());\n        marry(this::buyHouse);\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-6b71iae",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210707214420-6b71iae"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "构造器引用"
				}
			]
		},
		{
			"ID": "20210707214420-ohqyvfo",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-ohqyvfo"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "和方法引用类似，函数式接口的抽象方法的形参列表和构造器的形参列表一致，抽象方法的返回值类型即为构造器所属的类的类型。由于构造器的名称与类名完全一样，并不固定。所以构造器引用使用"
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "类名称::new"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 的格式表示"
				}
			]
		},
		{
			"ID": "20210707214420-vefj4z7",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-vefj4z7"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class Person {\n    private String name;\n    ...\n}\n// ------------------\n@FunctionalInterface\npublic interface PersonBuilder {\n    Person buildPerson(String name);\n}\n// ------------------\npublic class Demo {\n    public static void printName(String name, PersonBuilder builder) {\n        System.out.println(builder.buildPerson(name).getName());\n    }\n    public static void main(String[] args) {\n        //printName(\"赵丽颖\", name ‐\u003e new Person(name));\n        printName(\"赵丽颖\", Person::new);\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-zj2zfmy",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-zj2zfmy"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//Supplier中的T get()\n//Employee的空参构造器：Employee()\n@Test\npublic void test1(){\n\n  Supplier\u003cEmployee\u003e sup = new Supplier\u003cEmployee\u003e() {\n    @Override\n    public Employee get() {\n      return new Employee();\n    }\n  };\n  System.out.println(\"*******************\");\n\n  Supplier\u003cEmployee\u003e  sup1 = () -\u003e new Employee();\n  System.out.println(sup1.get());\n\n  System.out.println(\"*******************\");\n\n  Supplier\u003cEmployee\u003e  sup2 = Employee :: new;\n  System.out.println(sup2.get());\n}\n\n//Function中的R apply(T t)\n@Test\npublic void test2(){\n  Function\u003cInteger,Employee\u003e func1 = id -\u003e new Employee(id);\n  Employee employee = func1.apply(1001);\n  System.out.println(employee);\n\n  System.out.println(\"*******************\");\n\n  Function\u003cInteger,Employee\u003e func2 = Employee :: new;\n  Employee employee1 = func2.apply(1002);\n  System.out.println(employee1);\n\n}\n\n//BiFunction中的R apply(T t,U u)\n@Test\npublic void test3(){\n  BiFunction\u003cInteger,String,Employee\u003e func1 = (id,name) -\u003e new Employee(id,name);\n  System.out.println(func1.apply(1001,\"Tom\"));\n\n  System.out.println(\"*******************\");\n\n  BiFunction\u003cInteger,String,Employee\u003e func2 = Employee :: new;\n  System.out.println(func2.apply(1002,\"Tom\"));\n\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-qfvrvik",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210707214420-qfvrvik"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "数组的构造器引用"
				}
			]
		},
		{
			"ID": "20210707214420-d5qzzq8",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-d5qzzq8"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "数组也是"
				},
				{
					"Type": "NodeCodeSpan",
					"CodeMarkerLen": 1,
					"Children": [
						{
							"Type": "NodeCodeSpanOpenMarker",
							"Data": "`"
						},
						{
							"Type": "NodeCodeSpanContent",
							"Data": "Object"
						},
						{
							"Type": "NodeCodeSpanCloseMarker",
							"Data": "`"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": " 的子类对象，所以同样"
				},
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "具有构造器"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				},
				{
					"Type": "NodeText",
					"Data": "，只是语法稍有不同"
				}
			]
		},
		{
			"ID": "20210707214420-wi1ja2y",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-wi1ja2y"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@FunctionalInterface\npublic interface ArrayBuilder {\n    int[] buildArray(int length);\n}\npublic class Demo {\n    private static int[] initArray(int length, ArrayBuilder builder) {\n        return builder.buildArray(length);\n    }\n    public static void main(String[] args) {\n        //int[] array = initArray(10, length ‐\u003e new int[length]);\n        int[] array = initArray(10, int[]::new);\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-eyuq4hg",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-eyuq4hg"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "//Function中的R apply(T t)\n@Test\npublic void test4(){\n  Function\u003cInteger,String[]\u003e func1 = length -\u003e new String[length];\n  String[] arr1 = func1.apply(5);\n  System.out.println(Arrays.toString(arr1));\n\n  System.out.println(\"*******************\");\n\n  Function\u003cInteger,String[]\u003e func2 = String[] :: new;\n  String[] arr2 = func2.apply(10);\n  System.out.println(Arrays.toString(arr2));\n\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-uz6u65o",
			"Type": "NodeHeading",
			"HeadingLevel": 2,
			"Properties": {
				"id": "20210707214420-uz6u65o"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "## "
				},
				{
					"Type": "NodeText",
					"Data": "习题"
				}
			]
		},
		{
			"ID": "20210707214420-6xh4tqd",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-6xh4tqd"
			},
			"Children": [
				{
					"Type": "NodeStrong",
					"Children": [
						{
							"Type": "NodeStrongA6kOpenMarker",
							"Data": "**"
						},
						{
							"Type": "NodeText",
							"Data": "Lambda 接口在 Java 中只能用于方法的参数！！！"
						},
						{
							"Type": "NodeStrongA6kCloseMarker",
							"Data": "**"
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-179truf",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-179truf"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "Comparator 使用 🔥"
				}
			]
		},
		{
			"ID": "20210707214420-ynl5t3a",
			"Type": "NodeParagraph",
			"Properties": {
				"id": "20210707214420-ynl5t3a"
			},
			"Children": [
				{
					"Type": "NodeText",
					"Data": "使用 Collections.sort() 方法, 推荐直接使用 Stream，通过定制排序比较两个 Employee (先按年龄比，年龄相同按姓名比), 使用 Lambda 表达式作为参数传递。"
				}
			]
		},
		{
			"ID": "20210707214420-3kxj1o6",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-3kxj1o6"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class Employee {\n\n\tprivate int id;\n\tprivate String name;\n\tprivate int age;\n\tprivate double salary;\n\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-sac79a6",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-sac79a6"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "public class LambdaTest {\n\n    List\u003cEmployee\u003e emps = Arrays.asList(\n        new Employee(101, \"张三\", 18, 9999.99),\n        new Employee(102, \"李四\", 59, 6666.66),\n        new Employee(103, \"王五\", 18, 3333.33),\n        new Employee(104, \"赵六\", 8, 7777.77),\n        new Employee(105, \"田七\", 18, 5555.55)\n    );\n\n    @Test\n    public void test1() {\n        emps.stream().sorted((e1, e2) -\u003e {\n            if (e1.getAge() != e2.getAge()) {\n                return Integer.compare(e1.getAge(), e2.getAge());\n            } else {\n                return e1.getName().compareTo(e2.getName());\n            }\n        }).forEach(System.out::println);\n\n        /*Collections.sort(emps, (e1, e2) -\u003e {\n            if (e1.getAge() != e2.getAge()) {\n                return Integer.compare(e1.getAge(), e2.getAge());\n            } else {\n                return e1.getName().compareTo(e2.getName());\n            }\n        });*/\n\n        // Collections.sort 会提示直接使用如下方式\n        /*emps.sort((e1, e2) -\u003e {\n            if (e1.getAge() != e2.getAge()) {\n                return Integer.compare(e1.getAge(), e2.getAge());\n            } else {\n                return e1.getName().compareTo(e2.getName());\n            }\n        });*/\n    }\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-jamkinl",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-jamkinl"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "函数式接口 1 🔥"
				}
			]
		},
		{
			"ID": "20210707214420-o43eeeo",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1,
				"Tight": true,
				"Start": 1,
				"Delimiter": 46,
				"Padding": 4,
				"Marker": "MQ==",
				"Num": 1
			},
			"Properties": {
				"id": "20210707214420-o43eeeo"
			},
			"Children": [
				{
					"ID": "20210707214420-8y27l19",
					"Type": "NodeListItem",
					"Data": "1",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 1,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "MQ==",
						"Num": 1
					},
					"Properties": {
						"id": "20210707214420-8y27l19"
					},
					"Children": [
						{
							"ID": "20210707214420-4gklc6c",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-4gklc6c"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "声明函数式接口，接口中声明抽象方法："
								},
								{
									"Type": "NodeCodeSpan",
									"CodeMarkerLen": 1,
									"Children": [
										{
											"Type": "NodeCodeSpanOpenMarker",
											"Data": "`"
										},
										{
											"Type": "NodeCodeSpanContent",
											"Data": "String getValue(String str);"
										},
										{
											"Type": "NodeCodeSpanCloseMarker",
											"Data": "`"
										}
									]
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-8gls35u",
					"Type": "NodeListItem",
					"Data": "2",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 2,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "Mg==",
						"Num": 2
					},
					"Properties": {
						"id": "20210707214420-8gls35u"
					},
					"Children": [
						{
							"ID": "20210707214420-76pyn1f",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-76pyn1f"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "声明类 LambdaTest，类中"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "编写方法"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "使用接口作为参数，将一个字符串转换成大写，并作为方法的返回值。"
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-f7nc13m",
					"Type": "NodeListItem",
					"Data": "3",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 3,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "Mw==",
						"Num": 3
					},
					"Properties": {
						"id": "20210707214420-f7nc13m"
					},
					"Children": [
						{
							"ID": "20210707214420-htg8slt",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-htg8slt"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "再将一个字符串的第 2 个到第 4 个索引位置进行截取子串。"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-9o0v2am",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-9o0v2am"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@FunctionalInterface\npublic interface MyFunctional1 {\n    String getValue(String str);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-6qto4al",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-6qto4al"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Test\npublic void test2(){\n    String s = \"abcdEfg\";\n\n    String s1 = strHandler(s, String::toUpperCase);\n    System.out.println(s1);\n\n    String s2 = strHandler(s, str -\u003e str.substring(2, 5));\n    System.out.println(s2);\n}\n\n/**\n * 用于处理字符串\n */\nprivate String strHandler(String str, MyFunctional1 func){\n    return func.getValue(str);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-ut60cm0",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-ut60cm0"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "函数式接口 2 🔥"
				}
			]
		},
		{
			"ID": "20210707214420-kjos71e",
			"Type": "NodeList",
			"ListData": {
				"Typ": 1,
				"Tight": true,
				"Start": 1,
				"Delimiter": 46,
				"Padding": 4,
				"Marker": "MQ==",
				"Num": 1
			},
			"Properties": {
				"id": "20210707214420-kjos71e"
			},
			"Children": [
				{
					"ID": "20210707214420-baxl0er",
					"Type": "NodeListItem",
					"Data": "1",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 1,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "MQ==",
						"Num": 1
					},
					"Properties": {
						"id": "20210707214420-baxl0er"
					},
					"Children": [
						{
							"ID": "20210707214420-6nel6xu",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-6nel6xu"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "声明一个带两个"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "泛型的函数式接口"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，泛型类型为\u003cT,R\u003e : T 为参数，R 为返回值"
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-luzuzz1",
					"Type": "NodeListItem",
					"Data": "2",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 2,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "Mg==",
						"Num": 2
					},
					"Properties": {
						"id": "20210707214420-luzuzz1"
					},
					"Children": [
						{
							"ID": "20210707214420-kamszav",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-kamszav"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "接口中声明对应抽象方法"
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-tfwxfc7",
					"Type": "NodeListItem",
					"Data": "3",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 3,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "Mw==",
						"Num": 3
					},
					"Properties": {
						"id": "20210707214420-tfwxfc7"
					},
					"Children": [
						{
							"ID": "20210707214420-4cs3xda",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-4cs3xda"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "在 LambdaTest 类中"
								},
								{
									"Type": "NodeStrong",
									"Children": [
										{
											"Type": "NodeStrongA6kOpenMarker",
											"Data": "**"
										},
										{
											"Type": "NodeText",
											"Data": "声明方法"
										},
										{
											"Type": "NodeStrongA6kCloseMarker",
											"Data": "**"
										}
									]
								},
								{
									"Type": "NodeText",
									"Data": "，使用接口作为参数，计算两个 long 型参数的和"
								}
							]
						}
					]
				},
				{
					"ID": "20210707214420-37yauok",
					"Type": "NodeListItem",
					"Data": "4",
					"ListData": {
						"Typ": 1,
						"Tight": true,
						"Start": 4,
						"Delimiter": 46,
						"Padding": 4,
						"Marker": "NA==",
						"Num": 4
					},
					"Properties": {
						"id": "20210707214420-37yauok"
					},
					"Children": [
						{
							"ID": "20210707214420-vlirffh",
							"Type": "NodeParagraph",
							"Properties": {
								"id": "20210707214420-vlirffh"
							},
							"Children": [
								{
									"Type": "NodeText",
									"Data": "再计算两个 long 型参数的乘积"
								}
							]
						}
					]
				}
			]
		},
		{
			"ID": "20210707214420-am8eq4l",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-am8eq4l"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@FunctionalInterface\npublic interface MyFunctional2\u003cT, R\u003e {\n    R calc(T t1, T t2);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-vufu2qq",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-vufu2qq"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "@Test\nvoid test3() {\n    long l = calcSum(2, 3, Long::sum);\n    System.out.println(l);\n\n    long ll = calcSum(2, 3, (l1, l2) -\u003e l1 * l2);\n    System.out.println(ll);\n}\n\n/**\n * 用于处理两个long数的计算\n */\nprivate long calcSum(long l1, long l2, MyFunctional2\u003cLong,Long\u003e func){\n    return func.calc(l1, l2);\n}\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-brs6ogc",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-brs6ogc"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "Pedicate 接口使用 🔥"
				}
			]
		},
		{
			"ID": "20210707214420-cfjx2rh",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-cfjx2rh"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "Integer[] arr = {-12345, 9999, 520, 0, -38, -7758520, 941213};\n\nPredicate\u003cInteger\u003e p1 = i -\u003e i \u003e= 0; //使用lambda表达式创建Predicate对象p1,p1能判断整数是否是自然数\nPredicate\u003cInteger\u003e p2 = i -\u003e Math.abs(i) \u003e 100; //使用lambda表达式创建Predicate对象p2,p2能判断整数的绝对值是否大于100\nPredicate\u003cInteger\u003e p3 = i -\u003e i % 2 == 0; //使用lambda表达式创建Predicate对象p3,p3能判断整数是否是偶数\n\nint count1 = 0;\nint count2 = 0;\nint count3 = 0;\nint count4 = 0;\nfor (Integer i : arr) {\n    if (p1.test(i))\n        count1++;\n    if (p1.negate().test(i))\n        count2++;\n    if (p2.and(p3).test(i))\n        count3++;\n    if (p1.negate().or(p3).test(i))\n        count4++;\n}\nSystem.out.println(\"自然数个数:\"+count1);\nSystem.out.println(\"负整数个数:\"+count2);\nSystem.out.println(\"绝对值大于100的偶数的个数:\"+count3);\nSystem.out.println(\"负整数或偶数的数的个数:\"+count4);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		},
		{
			"ID": "20210707214420-cceob7b",
			"Type": "NodeHeading",
			"HeadingLevel": 3,
			"Properties": {
				"id": "20210707214420-cceob7b"
			},
			"Children": [
				{
					"Type": "NodeHeadingC8hMarker",
					"Data": "### "
				},
				{
					"Type": "NodeText",
					"Data": "Function 接口使用 🔥"
				}
			]
		},
		{
			"ID": "20210707214420-uxkctiq",
			"Type": "NodeCodeBlock",
			"IsFencedCodeBlock": true,
			"CodeBlockFenceChar": 96,
			"CodeBlockFenceLen": 3,
			"CodeBlockOpenFence": "YGBg",
			"CodeBlockInfo": "amF2YQ==",
			"CodeBlockCloseFence": "YGBg",
			"Properties": {
				"id": "20210707214420-uxkctiq"
			},
			"Children": [
				{
					"Type": "NodeCodeBlockFenceOpenMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				},
				{
					"Type": "NodeCodeBlockFenceInfoMarker",
					"CodeBlockInfo": "amF2YQ=="
				},
				{
					"Type": "NodeCodeBlockCode",
					"Data": "/**\n         * 1.\t使用lambda表达式分别将以下功能封装到Function对象中\n         * a)\t求Integer类型ArrayList中所有元素的平均数\n         * b)\t将Map\u003cString,Integer\u003e中value存到ArrayList\u003cInteger\u003e中\n         */\nFunction\u003cArrayList\u003cInteger\u003e, Integer\u003e avg = list -\u003e {\n    int sum = 0;\n    for (Integer i : list) {\n        sum += i;\n    }\n    return sum / list.size();\n};\n\nFunction\u003cMap\u003cString, Integer\u003e, ArrayList\u003cInteger\u003e\u003e change = map -\u003e {\n    ArrayList\u003cInteger\u003e list = new ArrayList\u003c\u003e();\n    map.entrySet().stream().forEach(s -\u003e list.add(s.getValue()));//或用values，addAll\n    return list;\n};\n\nHashMap\u003cString, Integer\u003e students = new HashMap\u003c\u003e();\nstudents.put(\"岑小村\", 59);\nstudents.put(\"谷天洛\", 82);\nstudents.put(\"渣渣辉\", 98);\nstudents.put(\"蓝小月\", 65);\nstudents.put(\"皮几万\", 70);\n\nint avg_score = change.andThen(avg).apply(students);\nSystem.out.println(avg_score);\n"
				},
				{
					"Type": "NodeCodeBlockFenceCloseMarker",
					"Data": "```",
					"CodeBlockFenceLen": 3
				}
			]
		}
	]
}